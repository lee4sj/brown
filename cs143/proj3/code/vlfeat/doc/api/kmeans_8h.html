<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
 <meta>
  <!-- Stylesheets -->
  <link href="../web.css" type="text/css" rel="stylesheet"></link>
  <link href="../pygmentize.css" type="text/css" rel="stylesheet"></link>
  <title>VLFeat - Documentation - C API</title>
  

  <!-- Scripts-->
  
 </meta>

 <!-- Body Start -->
 <body>
  <div id="header">
   <!-- Google CSE Search Box Begins -->
   <form action="http://www.vlfeat.org/search.html" method="get" id="cse-search-box" enctype="application/x-www-form-urlencoded">
    <div>
     <input type="hidden" name="cx" value="003215582122030917471:oq23albfeam"></input>
     <input type="hidden" name="cof" value="FORID:11"></input>
     <input type="hidden" name="ie" value="UTF-8"></input>
     <input type="text" name="q" size="31"></input>
     <input type="submit" name="sa" value="Search"></input>
    </div>
   </form>
   <script src="http://www.google.com/coop/cse/brand?form=cse-search-box&amp;lang=en" xml:space="preserve" type="text/javascript"></script>
   <!-- Google CSE Search Box Ends -->
   <h1><a shape="rect" href="../index.html" class="plain"><span id="vlfeat">VLFeat</span><span id="dotorg">.org</span></a></h1>
  </div>
  <div id="headbanner">
   Documentation - C API
  </div>
  <div id="pagebody">
   <div id="sidebar"> <!-- Navigation Start -->
    <ul>
<li><a href="../index.html">Home</a>
</li>
<li><a href="../download.html">Download</a>
</li>
<li><a href="../doc.html">Documentation</a>
<ul>
<li><a href="../mdoc/mdoc.html">Matlab API</a>
</li>
<li><a href="index.html" class='active' >C API</a>
</li>
<li><a href="../man/man.html">Man pages</a>
</li>
</ul></li>
<li><a href="../overview/tut.html">Tutorials</a>
</li>
<li><a href="../applications/apps.html">Applications</a>
</li>
</ul>

   </div> <!-- sidebar -->
   <div id="content">
    
    <div class="doxygen">
<!-- Generated by Doxygen 1.7.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<h1>kmeans.h File Reference</h1>  </div>
</div>
<div class="contents">

<p>K-means - Declaration.  
<a href="#_details">More...</a></p>
<code>#include &quot;<a class="el" href="generic_8h.html">generic.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="random_8h.html">random.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="mathop_8h.html">mathop.h</a>&quot;</code><br/>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVlKMeans.html">VlKMeans</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">K-means quantizer.  <a href="structVlKMeans.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmeans_8h.html#a4c431fed2c5377435e08cbad0040c9f3">VlKMeansAlgorithm</a> { <a class="el" href="kmeans_8h.html#a4c431fed2c5377435e08cbad0040c9f3a19e04f61cc224d6f970a6cba351d6692">VlKMeansLloyd</a>, 
<a class="el" href="kmeans_8h.html#a4c431fed2c5377435e08cbad0040c9f3a5f262d513ca0a82ddb577bbe31aa164c">VlKMeansElkan</a>, 
<a class="el" href="kmeans_8h.html#a4c431fed2c5377435e08cbad0040c9f3adc59056a09e72cdca518cfd6860d0ce4">VlKMeansANN</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>K-means algorithms. </p>
 <a href="kmeans_8h.html#a4c431fed2c5377435e08cbad0040c9f3">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmeans_8h.html#ab5a665f209dfbe8e9d53af18fdf489d5">VlKMeansInitialization</a> { <a class="el" href="kmeans_8h.html#ab5a665f209dfbe8e9d53af18fdf489d5a60e94b6baf611109b87ca291ff86943b">VlKMeansRandomSelection</a>, 
<a class="el" href="kmeans_8h.html#ab5a665f209dfbe8e9d53af18fdf489d5a314ecb9e2d2f166ce7199e1a6cb0594a">VlKMeansPlusPlus</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>K-means initialization algorithms. </p>
 <a href="kmeans_8h.html#ab5a665f209dfbe8e9d53af18fdf489d5">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Create and destroy</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structVlKMeans.html">VlKMeans</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmeans_8h.html#a868a729d2ea5b9f9fec15a18e0a27a76">vl_kmeans_new</a> (vl_type dataType, <a class="el" href="mathop_8h.html#aa4cc7d511f708d61bc8fe15c65ad6d74">VlVectorComparisonType</a> distance)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new KMeans object.  <a href="#a868a729d2ea5b9f9fec15a18e0a27a76"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structVlKMeans.html">VlKMeans</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmeans_8h.html#ae251eb379788d26613057f0014bb15bd">vl_kmeans_new_copy</a> (<a class="el" href="structVlKMeans.html">VlKMeans</a> const *kmeans)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new KMeans object by copy.  <a href="#ae251eb379788d26613057f0014bb15bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmeans_8h.html#a55a50b06dfd493861651200c61458609">vl_kmeans_delete</a> (<a class="el" href="structVlKMeans.html">VlKMeans</a> *self)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes a KMeans object.  <a href="#a55a50b06dfd493861651200c61458609"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Basic data processing</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmeans_8h.html#a77b5f58050110584e188534ad15c1dd0">vl_kmeans_reset</a> (<a class="el" href="structVlKMeans.html">VlKMeans</a> *self)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset state.  <a href="#a77b5f58050110584e188534ad15c1dd0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmeans_8h.html#a3f35fc9b75799b10a6e32ec81a9cd54d">vl_kmeans_cluster</a> (<a class="el" href="structVlKMeans.html">VlKMeans</a> *self, void const *data, <a class="el" href="host_8h.html#a0ee26101458c663510d620e3ee7e2555">vl_size</a> dimension, <a class="el" href="host_8h.html#a0ee26101458c663510d620e3ee7e2555">vl_size</a> numData, <a class="el" href="host_8h.html#a0ee26101458c663510d620e3ee7e2555">vl_size</a> numCenters)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Cluster data.  <a href="#a3f35fc9b75799b10a6e32ec81a9cd54d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmeans_8h.html#a3649fe42a94e9b4945511b5665f82355">vl_kmeans_quantize</a> (<a class="el" href="structVlKMeans.html">VlKMeans</a> *self, <a class="el" href="host_8h.html#aeb7c862765448a70017105efa4d25e7a">vl_uint32</a> *assignments, void *distances, void const *data, <a class="el" href="host_8h.html#a0ee26101458c663510d620e3ee7e2555">vl_size</a> numData)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Quantize data.  <a href="#a3649fe42a94e9b4945511b5665f82355"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Advanced data processing</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmeans_8h.html#ac86bd2fa181f6e23e22a6ad92f25288c">vl_kmeans_set_centers</a> (<a class="el" href="structVlKMeans.html">VlKMeans</a> *self, void const *centers, <a class="el" href="host_8h.html#a0ee26101458c663510d620e3ee7e2555">vl_size</a> dimension, <a class="el" href="host_8h.html#a0ee26101458c663510d620e3ee7e2555">vl_size</a> numCenters)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set centers.  <a href="#ac86bd2fa181f6e23e22a6ad92f25288c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmeans_8h.html#a087c6c6776ee025e1657b4f724418a61">vl_kmeans_seed_centers_with_rand_data</a> (<a class="el" href="structVlKMeans.html">VlKMeans</a> *self, void const *data, <a class="el" href="host_8h.html#a0ee26101458c663510d620e3ee7e2555">vl_size</a> dimensions, <a class="el" href="host_8h.html#a0ee26101458c663510d620e3ee7e2555">vl_size</a> numData, <a class="el" href="host_8h.html#a0ee26101458c663510d620e3ee7e2555">vl_size</a> numCenters)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Seed centers by randomly sampling data.  <a href="#a087c6c6776ee025e1657b4f724418a61"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmeans_8h.html#a4e66cedb1d3857d0ffc173ff010c0cbd">vl_kmeans_seed_centers_plus_plus</a> (<a class="el" href="structVlKMeans.html">VlKMeans</a> *self, void const *data, <a class="el" href="host_8h.html#a0ee26101458c663510d620e3ee7e2555">vl_size</a> dimensions, <a class="el" href="host_8h.html#a0ee26101458c663510d620e3ee7e2555">vl_size</a> numData, <a class="el" href="host_8h.html#a0ee26101458c663510d620e3ee7e2555">vl_size</a> numCenters)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Seed centers by the KMeans++ algorithm.  <a href="#a4e66cedb1d3857d0ffc173ff010c0cbd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmeans_8h.html#a9fd1885e6b4742a93b4672f56eb9f2ce">vl_kmeans_refine_centers</a> (<a class="el" href="structVlKMeans.html">VlKMeans</a> *self, void const *data, <a class="el" href="host_8h.html#a0ee26101458c663510d620e3ee7e2555">vl_size</a> numData)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Refine center locations.  <a href="#a9fd1885e6b4742a93b4672f56eb9f2ce"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Retrieve data and parameters</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vl_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmeans_8h.html#abc797cd0e7228d096313fd97b412a21c">vl_kmeans_get_data_type</a> (<a class="el" href="structVlKMeans.html">VlKMeans</a> const *self)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get data type.  <a href="#abc797cd0e7228d096313fd97b412a21c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="mathop_8h.html#aa4cc7d511f708d61bc8fe15c65ad6d74">VlVectorComparisonType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmeans_8h.html#a61bd032e28960a20cf86e8c77577b67e">vl_kmeans_get_distance</a> (<a class="el" href="structVlKMeans.html">VlKMeans</a> const *self)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get data type.  <a href="#a61bd032e28960a20cf86e8c77577b67e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="kmeans_8h.html#a4c431fed2c5377435e08cbad0040c9f3">VlKMeansAlgorithm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmeans_8h.html#ae6d9f44be8b5d6fc71f11554de742a63">vl_kmeans_get_algorithm</a> (<a class="el" href="structVlKMeans.html">VlKMeans</a> const *self)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get K-means algorithm.  <a href="#ae6d9f44be8b5d6fc71f11554de742a63"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="kmeans_8h.html#ab5a665f209dfbe8e9d53af18fdf489d5">VlKMeansInitialization</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmeans_8h.html#af920d0fc7e802901fd071eec3def47d2">vl_kmeans_get_initialization</a> (<a class="el" href="structVlKMeans.html">VlKMeans</a> const *self)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get K-means initialization algorithm.  <a href="#af920d0fc7e802901fd071eec3def47d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="host_8h.html#a0ee26101458c663510d620e3ee7e2555">vl_size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmeans_8h.html#ae84b1f054eacec5dd7cf2d54668ba181">vl_kmeans_get_num_repetitions</a> (<a class="el" href="structVlKMeans.html">VlKMeans</a> const *self)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get maximum number of repetitions.  <a href="#ae84b1f054eacec5dd7cf2d54668ba181"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="host_8h.html#a0ee26101458c663510d620e3ee7e2555">vl_size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmeans_8h.html#a16d8a8bb5d3d7484c4645561dc42ee53">vl_kmeans_get_dimension</a> (<a class="el" href="structVlKMeans.html">VlKMeans</a> const *self)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get data dimension.  <a href="#a16d8a8bb5d3d7484c4645561dc42ee53"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="host_8h.html#a0ee26101458c663510d620e3ee7e2555">vl_size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmeans_8h.html#acba49a529f1393cd04c02a6ef8e2cacd">vl_kmeans_get_num_centers</a> (<a class="el" href="structVlKMeans.html">VlKMeans</a> const *self)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of centers (K)  <a href="#acba49a529f1393cd04c02a6ef8e2cacd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmeans_8h.html#a7747422051ced08941d2306951445d79">vl_kmeans_get_verbosity</a> (<a class="el" href="structVlKMeans.html">VlKMeans</a> const *self)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get verbosity level.  <a href="#a7747422051ced08941d2306951445d79"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="host_8h.html#a0ee26101458c663510d620e3ee7e2555">vl_size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmeans_8h.html#a6312397c35e56ccd50ac1fa8dbc6bcc2">vl_kmeans_get_max_num_iterations</a> (<a class="el" href="structVlKMeans.html">VlKMeans</a> const *self)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get maximum number of iterations.  <a href="#a6312397c35e56ccd50ac1fa8dbc6bcc2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmeans_8h.html#a02365a4146fabad03f76bb4cdad7cb77">vl_kmeans_get_energy</a> (<a class="el" href="structVlKMeans.html">VlKMeans</a> const *self)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number energy of the current fit.  <a href="#a02365a4146fabad03f76bb4cdad7cb77"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmeans_8h.html#a69ecb61159ce9418679f5283c5cb427a">vl_kmeans_get_centers</a> (<a class="el" href="structVlKMeans.html">VlKMeans</a> const *self)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get centers.  <a href="#a69ecb61159ce9418679f5283c5cb427a"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Set parameters</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmeans_8h.html#ae2ab27c25bb4730d854219af20f37804">vl_kmeans_set_algorithm</a> (<a class="el" href="structVlKMeans.html">VlKMeans</a> *self, <a class="el" href="kmeans_8h.html#a4c431fed2c5377435e08cbad0040c9f3">VlKMeansAlgorithm</a> algorithm)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set K-means algorithm.  <a href="#ae2ab27c25bb4730d854219af20f37804"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmeans_8h.html#a7c61513feb74bb5393326ed3cced2650">vl_kmeans_set_initialization</a> (<a class="el" href="structVlKMeans.html">VlKMeans</a> *self, <a class="el" href="kmeans_8h.html#ab5a665f209dfbe8e9d53af18fdf489d5">VlKMeansInitialization</a> initialization)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set K-means initialization algorithm.  <a href="#a7c61513feb74bb5393326ed3cced2650"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmeans_8h.html#a7a1095cdba2192ee48e15d19144315fb">vl_kmeans_set_num_repetitions</a> (<a class="el" href="structVlKMeans.html">VlKMeans</a> *self, <a class="el" href="host_8h.html#a0ee26101458c663510d620e3ee7e2555">vl_size</a> numRepetitions)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set maximum number of repetitions.  <a href="#a7a1095cdba2192ee48e15d19144315fb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmeans_8h.html#a34f80e7e3f4c7213366b88169cc2f70f">vl_kmeans_set_max_num_iterations</a> (<a class="el" href="structVlKMeans.html">VlKMeans</a> *self, <a class="el" href="host_8h.html#a0ee26101458c663510d620e3ee7e2555">vl_size</a> maxNumIterations)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set maximum number of iterations.  <a href="#a34f80e7e3f4c7213366b88169cc2f70f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kmeans_8h.html#af2411b97e440ef5419657c41273d38cb">vl_kmeans_set_verbosity</a> (<a class="el" href="structVlKMeans.html">VlKMeans</a> *self, int verbosity)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set verbosity level.  <a href="#af2411b97e440ef5419657c41273d38cb"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h2><a class="anchor" id="kmeans-overview"></a>
Overview</h2>
<p><a class="el" href="kmeans_8h.html">kmeans.h</a> implements a number of algorithm for k-means quantisation. It supports</p>
<ul>
<li>data of type <code>float</code> or <code>double</code>;</li>
<li><em>l1</em> and <em>l2</em> distances;</li>
<li>random selection and <code>k-means++</code> initialization methods;</li>
<li>basic Lloyd and accelerated Elkan optimization methods.</li>
</ul>
<h2><a class="anchor" id="kmeans-usage"></a>
Usage</h2>
<p>To use <a class="el" href="kmeans_8h.html">kmeans.h</a> to learn clusters from some training data, instantiate a <a class="el" href="structVlKMeans.html" title="K-means quantizer.">VlKMeans</a> object, set the configuration parameters, initialise the cluster centers, and run the trainig code. For instance, to learn <code>numCenters</code> clusters from <code>numData</code> vectors of dimension <code>dimension</code> and storage type <code>float</code> using L2 distance and at most 100 Lloyd iterations of the Lloyd algorithm use:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;<a class="code" href="kmeans_8h.html" title="K-means - Declaration.">vl/kmeans.h</a>&gt;</span>

 <a class="code" href="kmeans_8h.html#a4c431fed2c5377435e08cbad0040c9f3" title="K-means algorithms.">VlKMeansAlgorithm</a> algorithm = <a class="code" href="kmeans_8h.html#a4c431fed2c5377435e08cbad0040c9f3a19e04f61cc224d6f970a6cba351d6692">VlKMeansLloyd</a> ;
 <a class="code" href="mathop_8h.html#aa4cc7d511f708d61bc8fe15c65ad6d74" title="Vector comparison types.">VlVectorComparisonType</a> distance = <a class="code" href="mathop_8h.html#af7397bb42d71000754eafba9458b09acab44b9322465d703274acfa21690de9fd">VlDistanceL2</a> ;
 KMeans * kmeans = <a class="code" href="kmeans_8c.html#a868a729d2ea5b9f9fec15a18e0a27a76" title="Create a new KMeans object.">vl_kmeans_new</a> (algorithm, distance, <a class="code" href="generic_8h.html#aa034d0b942f9800b2a02aeb30ff10fa2">VL_TYPE_FLOAT</a>) ;
 <a class="code" href="kmeans_8c.html#aad205598b82c6f516e68ed889e3fc19a" title="Seed centers by randomly sampling data.">vl_kmeans_seed_centers_with_rand_data</a> (kmeans, data, dimension, numData, numCenters) ;
 <a class="code" href="kmeans_8h.html#a34f80e7e3f4c7213366b88169cc2f70f" title="Set maximum number of iterations.">vl_kmeans_set_max_num_iterations</a> (kmeans, 100) ;
 <a class="code" href="kmeans_8c.html#a9fd1885e6b4742a93b4672f56eb9f2ce" title="Refine center locations.">vl_kmeans_refine_centers</a> (kmeans, data, numData) ;
</pre></div><p>Use <a class="el" href="kmeans_8h.html#a02365a4146fabad03f76bb4cdad7cb77" title="Get the number energy of the current fit.">vl_kmeans_get_energy</a> to get the solution energy (or an upper bound for the Elkan algorithm) and <a class="el" href="kmeans_8h.html#a69ecb61159ce9418679f5283c5cb427a" title="Get centers.">vl_kmeans_get_centers</a> to obtain the <code>numCluster</code> cluster centers. Use <a class="el" href="kmeans_8h.html#a3649fe42a94e9b4945511b5665f82355" title="Quantize data.">vl_kmeans_quantize</a> to quantize new data points.</p>
<h3><a class="anchor" id="kmeans-usage-init"></a>
Initialization algorithms</h3>
<p><a class="el" href="kmeans_8h.html">kmeans.h</a> supports the following cluster initialization algorithms:</p>
<ul>
<li><b>Random data points</b> (<a class="el" href="kmeans_8h.html#a087c6c6776ee025e1657b4f724418a61" title="Seed centers by randomly sampling data.">vl_kmeans_seed_centers_with_rand_data</a>) initialize the centers from a random selection of the training data.</li>
<li><b>k-means++</b> (<a class="el" href="kmeans_8h.html#a4e66cedb1d3857d0ffc173ff010c0cbd" title="Seed centers by the KMeans++ algorithm.">vl_kmeans_seed_centers_plus_plus</a>) initialize the centers from a random selection of the training data while attempting to obtain a good coverage of the dataset. This is the strategy from [1].</li>
</ul>
<h3><a class="anchor" id="kmeans-usage-optimizers"></a>
Optimization algorithms</h3>
<p><a class="el" href="kmeans_8h.html">kmeans.h</a> supports the following optimization algorithms:</p>
<ul>
<li><b>Lloyd</b> [2] (<a class="el" href="kmeans_8h.html#a4c431fed2c5377435e08cbad0040c9f3a19e04f61cc224d6f970a6cba351d6692">VlKMeansLloyd</a>). This is the standard k-means algorithm, alternating the estimation of the point-to-cluster memebrship and of the cluster centers (means in the Euclidean case). Estimating membership requires computing the distance of each point to all cluster centers, which can be extremely slow.</li>
<li><b>Elkan</b> [3] (<a class="el" href="kmeans_8h.html#a4c431fed2c5377435e08cbad0040c9f3a5f262d513ca0a82ddb577bbe31aa164c">VlKMeansElkan</a>). This is a variation of [2] that uses the triangular inequality to avoid many distance calculations when assigning points to clusters and is typically much faster than [2]. However, it uses storage proportional to the square of the number of clusters, which makes it unpractical for a very large number of clusters.</li>
</ul>
<h2><a class="anchor" id="kmeans-tech"></a>
Technical details</h2>
<p>Given data points <img class="formulaInl" alt="$ x_1, \dots, x_n \in \mathbb{R}^d $" src="form_126.png"/>, k-means searches for <img class="formulaInl" alt="$ k $" src="form_127.png"/> vectors <img class="formulaInl" alt="$ c_1, \dots, c_n \in \mathbb{R}^d $" src="form_128.png"/> (cluster centers) and a function <img class="formulaInl" alt="$ \pi : \{1, \dots, n\} \rightarrow \{1, \dots, k\} $" src="form_129.png"/> (cluster memberships) that minimize the objective:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ E(c_1,\dots,c_n,\pi) = \sum_{i=1}^n d^2(x_i, c_{\pi(i)}) \]" src="form_130.png"/>
</p>
<p>A simple procedure due to Lloyd [2] to locally optimize this objective alternates estimating the cluster centers and the membeship function. Specifically, given the membership function <img class="formulaInl" alt="$ \pi $" src="form_131.png"/>, the objective can be minimized independently for eac <img class="formulaInl" alt="$ c_k $" src="form_132.png"/> by minimizing</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \sum_{i : \pi(i) = k} d^2(x_i, c_k) \]" src="form_133.png"/>
</p>
<p>For the Euclidean distance, the minimizer is simply the mean of the points assigned to that cluster. For other distances, the minimizer is a generalized average. For instance, for the <img class="formulaInl" alt="$ l^1 $" src="form_134.png"/> distance, this is the median. Assuming that computing the average is linear in the number of points and the data dimension, this step requires <img class="formulaInl" alt="$ O(nd) $" src="form_135.png"/> operations.</p>
<p>Similarly, given the centers <img class="formulaInl" alt="$ c_1, \dots, c_k $" src="form_136.png"/>, the objective can be optimized independently for the membership <img class="formulaInl" alt="$ \pi(i) $" src="form_137.png"/> of each point <img class="formulaInl" alt="$ x_i $" src="form_98.png"/> by minimizing <img class="formulaInl" alt="$ d^2(x_i, c_{\pi(i)}) $" src="form_138.png"/> over <img class="formulaInl" alt="$ \pi(i) \in \{1, \dots, k\} $" src="form_139.png"/>. Assuming that computing a distance is <img class="formulaInl" alt="$ O(d) $" src="form_140.png"/>, this step requires <img class="formulaInl" alt="$ O(ndk) $" src="form_141.png"/> operations and dominates the other.</p>
<p>The algorithm usually starts by initializing the centers from a random selection of the data point.</p>
<h3><a class="anchor" id="kmeans-tech-kmeanspp"></a>
Initialization by k-means++</h3>
<p>[1] proposes a randomized initialization of the centers which improves upon random selection. The first center <img class="formulaInl" alt="$ c_1 $" src="form_142.png"/> is selected at random from the data points <img class="formulaInl" alt="$ x_1, \dots, x_n $" src="form_143.png"/> and the distance from this center to all points <img class="formulaInl" alt="$ d^2(x_i, c_1) $" src="form_144.png"/> is computed. Then the second center <img class="formulaInl" alt="$ c_2 $" src="form_145.png"/> is selected at random from the data points with probability proportional to the distance, and the procedure is repeated using the minimum distance to the centers collected so far.</p>
<h3><a class="anchor" id="kmeans-tech-elkan"></a>
Speeding up by using the triangular inequality</h3>
<p>[3] proposes to use the triangular inequality to avoid most distances calculations when computing point-to-cluster membership and the cluster centers did not change much from the previous iteration.</p>
<p>This uses two key ideas:</p>
<ul>
<li>If a point <img class="formulaInl" alt="$ x_i $" src="form_98.png"/> is very close to its current center <img class="formulaInl" alt="$ c_{\pi(i)} $" src="form_146.png"/> and this center is very far from another center <img class="formulaInl" alt="$ c $" src="form_147.png"/>, then the point cannot be assigned to <img class="formulaInl" alt="$ c $" src="form_147.png"/>. Specifically, if <img class="formulaInl" alt="$ d(x_i, c_{\pi(i)}) \leq d(c_{\pi(i)}, c) / 2 $" src="form_148.png"/>, then also <img class="formulaInl" alt="$ d(x_i, c_{\pi(i)}) \leq d(x_i, c) $" src="form_149.png"/>.</li>
</ul>
<ul>
<li>If a center <img class="formulaInl" alt="$ c $" src="form_147.png"/> is updated to <img class="formulaInl" alt="$ \hat c $" src="form_150.png"/>, then the variation of the distance of the center to any point can be bounded by <img class="formulaInl" alt="$ d(x, c) - d(c, \hat c) \leq d(x, \hat c) \leq d(x,c) + d(c, \hat c) $" src="form_151.png"/>.</li>
</ul>
<p>The first idea is used by keeping track of the inter-center distances and exlcuding reassigments to centers too far away from the current assigned center. The second idea is used by keeping for each point an upper bound to the distance to the currently assigned center and a lower bound to the distance to all the other centers. Unless such bounds do not intersect, then a point need not to be reassigned. See [3] for details.</p>
<h2><a class="anchor" id="kmeans-references"></a>
References</h2>
<ul>
<li>[1] D. Arthur and S. Vassilvitskii. <em>k-means++: The advantages of careful seeding.</em> In Proc. ACM-SIAM Symp. on Discrete Algorithms, 2007.</li>
</ul>
<ul>
<li>[2] S. Lloyd. <em>Least square quantization in PCM.</em> IEEE Trans. on Information Theory, 28(2), 1982.</li>
</ul>
<ul>
<li>[3] C. Elkan. <em>Using the triangle inequality to accelerate k-means.</em> In Proc. ICML, 2003.</li>
</ul>
<dl class="author"><dt><b>Author:</b></dt><dd>Andrea Vedaldi </dd></dl>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="a4c431fed2c5377435e08cbad0040c9f3"></a><!-- doxytag: member="kmeans.h::VlKMeansAlgorithm" ref="a4c431fed2c5377435e08cbad0040c9f3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="kmeans_8h.html#a4c431fed2c5377435e08cbad0040c9f3">VlKMeansAlgorithm</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a4c431fed2c5377435e08cbad0040c9f3a19e04f61cc224d6f970a6cba351d6692"></a><!-- doxytag: member="VlKMeansLloyd" ref="a4c431fed2c5377435e08cbad0040c9f3a19e04f61cc224d6f970a6cba351d6692" args="" -->VlKMeansLloyd</em>&nbsp;</td><td>
<p>Lloyd algorithm </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a4c431fed2c5377435e08cbad0040c9f3a5f262d513ca0a82ddb577bbe31aa164c"></a><!-- doxytag: member="VlKMeansElkan" ref="a4c431fed2c5377435e08cbad0040c9f3a5f262d513ca0a82ddb577bbe31aa164c" args="" -->VlKMeansElkan</em>&nbsp;</td><td>
<p>Elkan algorithm </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a4c431fed2c5377435e08cbad0040c9f3adc59056a09e72cdca518cfd6860d0ce4"></a><!-- doxytag: member="VlKMeansANN" ref="a4c431fed2c5377435e08cbad0040c9f3adc59056a09e72cdca518cfd6860d0ce4" args="" -->VlKMeansANN</em>&nbsp;</td><td>
<p>Approximate nearest neighbors </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ab5a665f209dfbe8e9d53af18fdf489d5"></a><!-- doxytag: member="kmeans.h::VlKMeansInitialization" ref="ab5a665f209dfbe8e9d53af18fdf489d5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="kmeans_8h.html#ab5a665f209dfbe8e9d53af18fdf489d5">VlKMeansInitialization</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ab5a665f209dfbe8e9d53af18fdf489d5a60e94b6baf611109b87ca291ff86943b"></a><!-- doxytag: member="VlKMeansRandomSelection" ref="ab5a665f209dfbe8e9d53af18fdf489d5a60e94b6baf611109b87ca291ff86943b" args="" -->VlKMeansRandomSelection</em>&nbsp;</td><td>
<p>Randomized selection </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ab5a665f209dfbe8e9d53af18fdf489d5a314ecb9e2d2f166ce7199e1a6cb0594a"></a><!-- doxytag: member="VlKMeansPlusPlus" ref="ab5a665f209dfbe8e9d53af18fdf489d5a314ecb9e2d2f166ce7199e1a6cb0594a" args="" -->VlKMeansPlusPlus</em>&nbsp;</td><td>
<p>Plus plus raondomized selection </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a3f35fc9b75799b10a6e32ec81a9cd54d"></a><!-- doxytag: member="kmeans.h::vl_kmeans_cluster" ref="a3f35fc9b75799b10a6e32ec81a9cd54d" args="(VlKMeans *self, void const *data, vl_size dimension, vl_size numData, vl_size numCenters)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vl_kmeans_cluster </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVlKMeans.html">VlKMeans</a> *&#160;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="host_8h.html#a0ee26101458c663510d620e3ee7e2555">vl_size</a>&#160;</td>
          <td class="paramname"> <em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="host_8h.html#a0ee26101458c663510d620e3ee7e2555">vl_size</a>&#160;</td>
          <td class="paramname"> <em>numData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="host_8h.html#a0ee26101458c663510d620e3ee7e2555">vl_size</a>&#160;</td>
          <td class="paramname"> <em>numCenters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>KMeans object. </td></tr>
    <tr><td class="paramname">data</td><td>data to quantize. </td></tr>
    <tr><td class="paramname">dimension</td><td>data dimension. </td></tr>
    <tr><td class="paramname">numData</td><td>number of data points. </td></tr>
    <tr><td class="paramname">numCenters</td><td>number of clusters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>K-means energy at the end of optimization.</dd></dl>
<p>The function initializes the centers by using the initialization algorithm set by <a class="el" href="kmeans_8h.html#a7c61513feb74bb5393326ed3cced2650" title="Set K-means initialization algorithm.">vl_kmeans_set_initialization</a> and refines them by the quantization algorithm set by <a class="el" href="kmeans_8h.html#ae2ab27c25bb4730d854219af20f37804" title="Set K-means algorithm.">vl_kmeans_set_algorithm</a>. The process is repeated one or more times (see <a class="el" href="kmeans_8h.html#a7a1095cdba2192ee48e15d19144315fb" title="Set maximum number of repetitions.">vl_kmeans_set_num_repetitions</a>) and the resutl with smaller energy is retained. </p>

</div>
</div>
<a class="anchor" id="a55a50b06dfd493861651200c61458609"></a><!-- doxytag: member="kmeans.h::vl_kmeans_delete" ref="a55a50b06dfd493861651200c61458609" args="(VlKMeans *self)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vl_kmeans_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVlKMeans.html">VlKMeans</a> *&#160;</td>
          <td class="paramname"> <em>self</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>KMeans object instance.</td></tr>
  </table>
  </dd>
</dl>
<p>The function deletes the KMeans object instance created by <a class="el" href="kmeans_8h.html#a868a729d2ea5b9f9fec15a18e0a27a76" title="Create a new KMeans object.">vl_kmeans_new</a>. </p>

</div>
</div>
<a class="anchor" id="ae6d9f44be8b5d6fc71f11554de742a63"></a><!-- doxytag: member="kmeans.h::vl_kmeans_get_algorithm" ref="ae6d9f44be8b5d6fc71f11554de742a63" args="(VlKMeans const *self)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="kmeans_8h.html#a4c431fed2c5377435e08cbad0040c9f3">VlKMeansAlgorithm</a> vl_kmeans_get_algorithm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVlKMeans.html">VlKMeans</a> const *&#160;</td>
          <td class="paramname"> <em>self</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>KMeans object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>algorithm. </dd></dl>

</div>
</div>
<a class="anchor" id="a69ecb61159ce9418679f5283c5cb427a"></a><!-- doxytag: member="kmeans.h::vl_kmeans_get_centers" ref="a69ecb61159ce9418679f5283c5cb427a" args="(VlKMeans const *self)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void const * vl_kmeans_get_centers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVlKMeans.html">VlKMeans</a> const *&#160;</td>
          <td class="paramname"> <em>self</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>KMeans object instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>cluster centers. </dd></dl>

</div>
</div>
<a class="anchor" id="abc797cd0e7228d096313fd97b412a21c"></a><!-- doxytag: member="kmeans.h::vl_kmeans_get_data_type" ref="abc797cd0e7228d096313fd97b412a21c" args="(VlKMeans const *self)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vl_type vl_kmeans_get_data_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVlKMeans.html">VlKMeans</a> const *&#160;</td>
          <td class="paramname"> <em>self</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>KMeans object instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>data type. </dd></dl>

</div>
</div>
<a class="anchor" id="a16d8a8bb5d3d7484c4645561dc42ee53"></a><!-- doxytag: member="kmeans.h::vl_kmeans_get_dimension" ref="a16d8a8bb5d3d7484c4645561dc42ee53" args="(VlKMeans const *self)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="host_8h.html#a0ee26101458c663510d620e3ee7e2555">vl_size</a> vl_kmeans_get_dimension </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVlKMeans.html">VlKMeans</a> const *&#160;</td>
          <td class="paramname"> <em>self</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>KMeans object instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>data dimension. </dd></dl>

</div>
</div>
<a class="anchor" id="a61bd032e28960a20cf86e8c77577b67e"></a><!-- doxytag: member="kmeans.h::vl_kmeans_get_distance" ref="a61bd032e28960a20cf86e8c77577b67e" args="(VlKMeans const *self)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mathop_8h.html#aa4cc7d511f708d61bc8fe15c65ad6d74">VlVectorComparisonType</a> vl_kmeans_get_distance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVlKMeans.html">VlKMeans</a> const *&#160;</td>
          <td class="paramname"> <em>self</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>KMeans object instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>data type. </dd></dl>

</div>
</div>
<a class="anchor" id="a02365a4146fabad03f76bb4cdad7cb77"></a><!-- doxytag: member="kmeans.h::vl_kmeans_get_energy" ref="a02365a4146fabad03f76bb4cdad7cb77" args="(VlKMeans const *self)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vl_kmeans_get_energy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVlKMeans.html">VlKMeans</a> const *&#160;</td>
          <td class="paramname"> <em>self</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>KMeans object instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>energy. </dd></dl>

</div>
</div>
<a class="anchor" id="af920d0fc7e802901fd071eec3def47d2"></a><!-- doxytag: member="kmeans.h::vl_kmeans_get_initialization" ref="af920d0fc7e802901fd071eec3def47d2" args="(VlKMeans const *self)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="kmeans_8h.html#ab5a665f209dfbe8e9d53af18fdf489d5">VlKMeansInitialization</a> vl_kmeans_get_initialization </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVlKMeans.html">VlKMeans</a> const *&#160;</td>
          <td class="paramname"> <em>self</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>KMeans object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>algorithm. </dd></dl>

</div>
</div>
<a class="anchor" id="a6312397c35e56ccd50ac1fa8dbc6bcc2"></a><!-- doxytag: member="kmeans.h::vl_kmeans_get_max_num_iterations" ref="a6312397c35e56ccd50ac1fa8dbc6bcc2" args="(VlKMeans const *self)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="host_8h.html#a0ee26101458c663510d620e3ee7e2555">vl_size</a> vl_kmeans_get_max_num_iterations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVlKMeans.html">VlKMeans</a> const *&#160;</td>
          <td class="paramname"> <em>self</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>KMeans object instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>maximum number of iterations. </dd></dl>

</div>
</div>
<a class="anchor" id="acba49a529f1393cd04c02a6ef8e2cacd"></a><!-- doxytag: member="kmeans.h::vl_kmeans_get_num_centers" ref="acba49a529f1393cd04c02a6ef8e2cacd" args="(VlKMeans const *self)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="host_8h.html#a0ee26101458c663510d620e3ee7e2555">vl_size</a> vl_kmeans_get_num_centers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVlKMeans.html">VlKMeans</a> const *&#160;</td>
          <td class="paramname"> <em>self</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>KMeans object instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of centers. </dd></dl>

</div>
</div>
<a class="anchor" id="ae84b1f054eacec5dd7cf2d54668ba181"></a><!-- doxytag: member="kmeans.h::vl_kmeans_get_num_repetitions" ref="ae84b1f054eacec5dd7cf2d54668ba181" args="(VlKMeans const *self)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="host_8h.html#a0ee26101458c663510d620e3ee7e2555">vl_size</a> vl_kmeans_get_num_repetitions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVlKMeans.html">VlKMeans</a> const *&#160;</td>
          <td class="paramname"> <em>self</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>KMeans object instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>current number of repretitions for quantization. </dd></dl>

</div>
</div>
<a class="anchor" id="a7747422051ced08941d2306951445d79"></a><!-- doxytag: member="kmeans.h::vl_kmeans_get_verbosity" ref="a7747422051ced08941d2306951445d79" args="(VlKMeans const *self)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vl_kmeans_get_verbosity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVlKMeans.html">VlKMeans</a> const *&#160;</td>
          <td class="paramname"> <em>self</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>KMeans object instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>verbosity level. </dd></dl>

</div>
</div>
<a class="anchor" id="a868a729d2ea5b9f9fec15a18e0a27a76"></a><!-- doxytag: member="kmeans.h::vl_kmeans_new" ref="a868a729d2ea5b9f9fec15a18e0a27a76" args="(vl_type dataType, VlVectorComparisonType distance)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structVlKMeans.html">VlKMeans</a>* vl_kmeans_new </td>
          <td>(</td>
          <td class="paramtype">vl_type&#160;</td>
          <td class="paramname"> <em>dataType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mathop_8h.html#aa4cc7d511f708d61bc8fe15c65ad6d74">VlVectorComparisonType</a>&#160;</td>
          <td class="paramname"> <em>distance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dataType</td><td>type of data (<a class="el" href="generic_8h.html#aa034d0b942f9800b2a02aeb30ff10fa2">VL_TYPE_FLOAT</a> or <a class="el" href="generic_8h.html#a41d6691dac0cc3648ca9701d27e5d2b0">VL_TYPE_DOUBLE</a>) </td></tr>
    <tr><td class="paramname">distance</td><td>distance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>new KMeans object instance. </dd></dl>

</div>
</div>
<a class="anchor" id="ae251eb379788d26613057f0014bb15bd"></a><!-- doxytag: member="kmeans.h::vl_kmeans_new_copy" ref="ae251eb379788d26613057f0014bb15bd" args="(VlKMeans const *kmeans)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structVlKMeans.html">VlKMeans</a>* vl_kmeans_new_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVlKMeans.html">VlKMeans</a> const *&#160;</td>
          <td class="paramname"> <em>kmeans</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">kmeans</td><td>KMeans object to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>new copy. </dd></dl>

</div>
</div>
<a class="anchor" id="a3649fe42a94e9b4945511b5665f82355"></a><!-- doxytag: member="kmeans.h::vl_kmeans_quantize" ref="a3649fe42a94e9b4945511b5665f82355" args="(VlKMeans *self, vl_uint32 *assignments, void *distances, void const *data, vl_size numData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vl_kmeans_quantize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVlKMeans.html">VlKMeans</a> *&#160;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="host_8h.html#aeb7c862765448a70017105efa4d25e7a">vl_uint32</a> *&#160;</td>
          <td class="paramname"> <em>assignments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"> <em>distances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="host_8h.html#a0ee26101458c663510d620e3ee7e2555">vl_size</a>&#160;</td>
          <td class="paramname"> <em>numData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>KMeans object. </td></tr>
    <tr><td class="paramname">assignments</td><td>data to centers assignments. </td></tr>
    <tr><td class="paramname">distances</td><td>data to closes center distance/ </td></tr>
    <tr><td class="paramname">data</td><td>data to quantize. </td></tr>
    <tr><td class="paramname">numData</td><td>number of data points. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9fd1885e6b4742a93b4672f56eb9f2ce"></a><!-- doxytag: member="kmeans.h::vl_kmeans_refine_centers" ref="a9fd1885e6b4742a93b4672f56eb9f2ce" args="(VlKMeans *self, void const *data, vl_size numData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vl_kmeans_refine_centers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVlKMeans.html">VlKMeans</a> *&#160;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="host_8h.html#a0ee26101458c663510d620e3ee7e2555">vl_size</a>&#160;</td>
          <td class="paramname"> <em>numData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>KMeans object. </td></tr>
    <tr><td class="paramname">data</td><td>data to quantize. </td></tr>
    <tr><td class="paramname">numData</td><td>number of data points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>K-means energy at the end of optimization.</dd></dl>
<p>The function calls the underlying K-means quantization algorithm (<a class="el" href="kmeans_8h.html#a4c431fed2c5377435e08cbad0040c9f3">VlKMeansAlgorithm</a>) to quantize the specified data <em>data</em>. The function assumes that the cluster centers have already been assigned by using one of the seeding functions, or by setting them. </p>

</div>
</div>
<a class="anchor" id="a77b5f58050110584e188534ad15c1dd0"></a><!-- doxytag: member="kmeans.h::vl_kmeans_reset" ref="a77b5f58050110584e188534ad15c1dd0" args="(VlKMeans *self)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vl_kmeans_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVlKMeans.html">VlKMeans</a> *&#160;</td>
          <td class="paramname"> <em>self</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The function reset the state of the KMeans object. It deletes any stored centers, releasing the corresponding memory. This cancels the effect of seeding or setting the centers, but does not change the other configuration parameters. </p>

</div>
</div>
<a class="anchor" id="a4e66cedb1d3857d0ffc173ff010c0cbd"></a><!-- doxytag: member="kmeans.h::vl_kmeans_seed_centers_plus_plus" ref="a4e66cedb1d3857d0ffc173ff010c0cbd" args="(VlKMeans *self, void const *data, vl_size dimensions, vl_size numData, vl_size numCenters)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vl_kmeans_seed_centers_plus_plus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVlKMeans.html">VlKMeans</a> *&#160;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="host_8h.html#a0ee26101458c663510d620e3ee7e2555">vl_size</a>&#160;</td>
          <td class="paramname"> <em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="host_8h.html#a0ee26101458c663510d620e3ee7e2555">vl_size</a>&#160;</td>
          <td class="paramname"> <em>numData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="host_8h.html#a0ee26101458c663510d620e3ee7e2555">vl_size</a>&#160;</td>
          <td class="paramname"> <em>numCenters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>KMeans object. </td></tr>
    <tr><td class="paramname">data</td><td>data to sample from. </td></tr>
    <tr><td class="paramname">dimension</td><td>data dimension. </td></tr>
    <tr><td class="paramname">numData</td><td>nmber of data points. </td></tr>
    <tr><td class="paramname">numCenters</td><td>number of centers. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a087c6c6776ee025e1657b4f724418a61"></a><!-- doxytag: member="kmeans.h::vl_kmeans_seed_centers_with_rand_data" ref="a087c6c6776ee025e1657b4f724418a61" args="(VlKMeans *self, void const *data, vl_size dimensions, vl_size numData, vl_size numCenters)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vl_kmeans_seed_centers_with_rand_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVlKMeans.html">VlKMeans</a> *&#160;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="host_8h.html#a0ee26101458c663510d620e3ee7e2555">vl_size</a>&#160;</td>
          <td class="paramname"> <em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="host_8h.html#a0ee26101458c663510d620e3ee7e2555">vl_size</a>&#160;</td>
          <td class="paramname"> <em>numData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="host_8h.html#a0ee26101458c663510d620e3ee7e2555">vl_size</a>&#160;</td>
          <td class="paramname"> <em>numCenters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>KMeans object. </td></tr>
    <tr><td class="paramname">data</td><td>data to sample from. </td></tr>
    <tr><td class="paramname">dimension</td><td>data dimension. </td></tr>
    <tr><td class="paramname">numData</td><td>nmber of data points. </td></tr>
    <tr><td class="paramname">numCenters</td><td>number of centers.</td></tr>
  </table>
  </dd>
</dl>
<p>The function seeds the KMeans centers by randomly sampling the data <em>data</em>. </p>

</div>
</div>
<a class="anchor" id="ae2ab27c25bb4730d854219af20f37804"></a><!-- doxytag: member="kmeans.h::vl_kmeans_set_algorithm" ref="ae2ab27c25bb4730d854219af20f37804" args="(VlKMeans *self, VlKMeansAlgorithm algorithm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vl_kmeans_set_algorithm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVlKMeans.html">VlKMeans</a> *&#160;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kmeans_8h.html#a4c431fed2c5377435e08cbad0040c9f3">VlKMeansAlgorithm</a>&#160;</td>
          <td class="paramname"> <em>algorithm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>KMeans object. </td></tr>
    <tr><td class="paramname">algorithm</td><td>K-means algorithm. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac86bd2fa181f6e23e22a6ad92f25288c"></a><!-- doxytag: member="kmeans.h::vl_kmeans_set_centers" ref="ac86bd2fa181f6e23e22a6ad92f25288c" args="(VlKMeans *self, void const *centers, vl_size dimension, vl_size numCenters)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vl_kmeans_set_centers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVlKMeans.html">VlKMeans</a> *&#160;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"> <em>centers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="host_8h.html#a0ee26101458c663510d620e3ee7e2555">vl_size</a>&#160;</td>
          <td class="paramname"> <em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="host_8h.html#a0ee26101458c663510d620e3ee7e2555">vl_size</a>&#160;</td>
          <td class="paramname"> <em>numCenters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>KMeans object. </td></tr>
    <tr><td class="paramname">centers</td><td>centers to copy. </td></tr>
    <tr><td class="paramname">dimension</td><td>data dimension. </td></tr>
    <tr><td class="paramname">numCenters</td><td>number of centers. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7c61513feb74bb5393326ed3cced2650"></a><!-- doxytag: member="kmeans.h::vl_kmeans_set_initialization" ref="a7c61513feb74bb5393326ed3cced2650" args="(VlKMeans *self, VlKMeansInitialization initialization)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vl_kmeans_set_initialization </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVlKMeans.html">VlKMeans</a> *&#160;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kmeans_8h.html#ab5a665f209dfbe8e9d53af18fdf489d5">VlKMeansInitialization</a>&#160;</td>
          <td class="paramname"> <em>initialization</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>KMeans object. </td></tr>
    <tr><td class="paramname">initialization</td><td>initialization. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a34f80e7e3f4c7213366b88169cc2f70f"></a><!-- doxytag: member="kmeans.h::vl_kmeans_set_max_num_iterations" ref="a34f80e7e3f4c7213366b88169cc2f70f" args="(VlKMeans *self, vl_size maxNumIterations)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vl_kmeans_set_max_num_iterations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVlKMeans.html">VlKMeans</a> *&#160;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="host_8h.html#a0ee26101458c663510d620e3ee7e2555">vl_size</a>&#160;</td>
          <td class="paramname"> <em>maxNumIterations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>KMeans filter. </td></tr>
    <tr><td class="paramname">maxNumIterations</td><td>maximum number of iterations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7a1095cdba2192ee48e15d19144315fb"></a><!-- doxytag: member="kmeans.h::vl_kmeans_set_num_repetitions" ref="a7a1095cdba2192ee48e15d19144315fb" args="(VlKMeans *self, vl_size numRepetitions)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vl_kmeans_set_num_repetitions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVlKMeans.html">VlKMeans</a> *&#160;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="host_8h.html#a0ee26101458c663510d620e3ee7e2555">vl_size</a>&#160;</td>
          <td class="paramname"> <em>numRepetitions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>KMeans object instance. </td></tr>
    <tr><td class="paramname">numRepetitions</td><td>maximum number of repetitions. The number of repetitions cannot be smaller than 1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af2411b97e440ef5419657c41273d38cb"></a><!-- doxytag: member="kmeans.h::vl_kmeans_set_verbosity" ref="af2411b97e440ef5419657c41273d38cb" args="(VlKMeans *self, int verbosity)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vl_kmeans_set_verbosity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVlKMeans.html">VlKMeans</a> *&#160;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>verbosity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>KMeans object instance. </td></tr>
    <tr><td class="paramname">verbosity</td><td>verbosity level. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
     <!-- Doc Here -->
    </div>
   
   </div>
   <div class="clear">&nbsp;</div>
  </div> <!-- pagebody -->
  <div id="footer">
   &copy; 2005-11 Andrea Vedaldi and Brian Fulkerson
  </div> <!-- footer -->

  <!-- Google Analytics Begins -->
  <script xml:space="preserve" type="text/javascript">
   //<![CDATA[
    var localre = /vlfeat.org/;
    if(document.location.host.search(localre) != -1)
    {
   var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
   document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
   }
   //]]>
  </script>
  <script xml:space="preserve" type="text/javascript">
    //<![CDATA[
    var localre = /vlfeat.org/;
    if(document.location.host.search(localre) != -1)
    {

   try {
   var pageTracker = _gat._getTracker("UA-4936091-2");
   pageTracker._trackPageview();
   } catch(err) {}

   }
   //]]>
  </script>
  <!-- Google Analytics Ends -->
 </body>
</html>

 
