%!PS-Adobe-3.0 EPSF-3.0
%%Creator: Adobe Illustrator(r) 6.0.2
%%For: (CEPUB) (Addison Wesley Longman)
%%Title: (AW back cover art, black)
%%CreationDate: (9/10/97) (2:31 PM)
%%BoundingBox: 303 418 417 434
%%HiResBoundingBox: 303.2469 418.1163 416.5921 433.6999
%%DocumentProcessColors: Black
%%DocumentSuppliedResources: procset Adobe_level2_AI5 1.0 0
%%+ procset Adobe_Illustrator_AI6_vars Adobe_Illustrator_AI6
%%+ procset Adobe_Illustrator_AI5 1.0 0
%AI5_FileFormat 2.1
%AI3_ColorUsage: Black&White
%%CMYKCustomColor: 0.45 0 1 0 (Lime Green)
%%+ 0 0 1 0.51 (PANTONE 105 CV)
%%+ 0 0.43 1 0.34 (PANTONE 154 CV)
%%+ 1 0.51 0 0.3 (PANTONE 541 CV)
%%+ 0.38 0.09 0 0 (PANTONE 544 CV)
%%+ 1 0.4 0.15 0 (Turquoise)
%%+ 0.25 1 0.25 0 (Violet Red)
%%AI6_ColorSeparationSet: 1 1 (AI6 Default Color Separation Set)
%%+ Options: 1 16 0 1 0 1 1 1 0 1 1 1 1 18 0 0 0 0 0 0 0 0 -1 -1
%%+ PPD: 1 21 0 0 60 45 2 2 1 0 0 1 0 0 0 0 0 0 0 0 0 0 ()
%AI3_TemplateBox: 306 396 306 396
%AI3_TileBox: -85 128 696 666
%AI3_DocumentPreview: Header
%AI5_ArtSize: 842 595
%AI5_RulerUnits: 1
%AI5_ArtFlags: 1 0 0 1 0 0 1 1 0
%AI5_TargetResolution: 800
%AI5_NumLayers: 1
%AI5_OpenToView: 286 468 6 1018 725 18 1 1 3 40
%AI5_OpenViewLayers: 7
%%EndComments
%%BeginProlog

% ------------------------------------------------------
%%BeginResource: procset Adobe_level2_AI5 1.2 0
%%Title: (Adobe Illustrator (R) Version 5.0 Level 2 Emulation)
%%Version: 1.2 0
%%CreationDate: (04/10/93) ()
%%Copyright: ((C) 1987-1996 Adobe Systems Incorporated All Rights Reserved)
% ------------------------------------------------------

userdict /Adobe_level2_AI5 23 dict dup begin
	put

% use packed arrays immediately
	% packedarray emulation
	/packedarray where not
	{
		userdict begin
		/packedarray
		{
			array astore readonly
		} bind def
		/setpacking /pop load def
		/currentpacking false def
		end
		0
	} if
	pop

% activate packing now
	userdict /defaultpacking currentpacking put true setpacking


% initialize, terminate
	% note : no binding loop needed here by design

	/initialize
	{
		Adobe_level2_AI5 begin
	} bind def
	/terminate
	{
		currentdict Adobe_level2_AI5 eq
		{
			end
		} if
	} bind def

% mark for later stack clean-up
	mark

% custom color business
	/setcustomcolor where not
	{
		/findcmykcustomcolor
		{
			5 packedarray
		} bind def
		/setcustomcolor
		{
			exch aload pop pop
			4
			{
				4 index mul 4 1 roll
			} repeat
			5 -1 roll pop
			setcmykcolor
		}	% don't bind 'setcmykcolor in this procedure
		def
	} if

%	new version checks for non-numeric version strings (5.0.1 fix bh 10/25/93)
%	/gt38? {version cvx exec} stopped {pop true} {38 gt} ifelse def
	
%	newer version handles errors on clones with cvx or exec which would leave junk on the stack
%	(bh 12/2/93)
	/gt38? mark {version cvr cvx exec} stopped {cleartomark true} {38 gt exch pop} ifelse def

	userdict /deviceDPI 72 0 matrix defaultmatrix dtransform dup mul exch dup mul add sqrt put

% test for Level 2 availability
	userdict /level2?
	systemdict /languagelevel known dup
	{
		pop systemdict /languagelevel get 2 ge
	} if
	put


/level2ScreenFreq		%	halftoneDict level2ScreenFreq screenFreq
{
	begin
		60	% 60 lpi is default
		HalftoneType 1 eq
		{
			pop Frequency
		} if
		HalftoneType 2 eq
		{
			pop GrayFrequency
		} if
		HalftoneType 5 eq
		{
			pop Default level2ScreenFreq
		} if
	end
} bind def

userdict /currentScreenFreq  
	level2? {currenthalftone level2ScreenFreq} {currentscreen pop pop} ifelse put

level2? not
	{
		% LEVEL 1+ EMULATIONS (typesetter/color printer extensions)

		% cmyk => gray conversion emulation
		% note this revision approved by Ed Taft
		% for correcting the out of gamut problem
		% in our current emulations

		% don't bind these guys so 'setgray/currentgray can be overloaded
		/setcmykcolor where not
		{
			% see red book II, pp. 305
			/setcmykcolor
			{
				exch .11 mul add exch .59 mul add exch .3 mul add
				1 exch sub setgray
			} def
		} if

		/currentcmykcolor where not
		{
			/currentcmykcolor
			{
				0 0 0 1 currentgray sub
			} def
		} if


		% LEVEL 2 EMULATIONS

		% setoverprint emulation
		/setoverprint where not
		{
			/setoverprint /pop load def
		} if

		% selectfont emulation
		/selectfont where not
		{
			/selectfont
			{
				exch findfont exch
				dup type /arraytype eq
				{
					makefont
				}
				{
					scalefont
				} ifelse
				setfont
			} bind def
		} if

		% cshow emulation
		/cshow where not
		{
			% {proc} (string)
			/cshow
			{
				[
				0 0 5 -1 roll aload pop
				] cvx bind forall
			} bind def
		} if
	} if

% clean up
	cleartomark

	/anyColor?
	{
		add add add 0 ne
	} bind def

	/testColor
	{
		gsave
		setcmykcolor currentcmykcolor
		grestore
	} bind def

	/testCMYKColorThrough
	{
		testColor anyColor?
	} bind def

	userdict /composite?
	level2?
	{
		gsave 1 1 1 1 setcmykcolor currentcmykcolor grestore
		add add add 4 eq
	}
	{
		1 0 0 0 testCMYKColorThrough
		0 1 0 0 testCMYKColorThrough
		0 0 1 0 testCMYKColorThrough
		0 0 0 1 testCMYKColorThrough
		and and and
	} ifelse
	put

% *** other separation state tests if we're not on a composite page	
	composite? not
	{
		userdict begin
		gsave
		/cyan? 1 0 0 0 testCMYKColorThrough def
		/magenta? 0 1 0 0 testCMYKColorThrough def
		/yellow? 0 0 1 0 testCMYKColorThrough def
		/black? 0 0 0 1 testCMYKColorThrough def
		grestore
		/isCMYKSep? cyan? magenta? yellow? black? or or or def
		/customColor? isCMYKSep? not def
		end
	} if

	end defaultpacking setpacking

%%EndResource

% ------------------------------------------------------
%%BeginProcSet: Adobe_ColorImage_AI6 1.0 0
% ColorImage Emulation and Separation Code for Grayscale, RGB and CMYK images
% Version 1.0 12/25/95
% Copyright (C) 1995-96
% Adobe Systems Incorporated
% All Rights Reserved
% ------------------------------------------------------

userdict /Adobe_ColorImage_AI6 known not
{
	userdict /Adobe_ColorImage_AI6 17 dict put 
} if
userdict /Adobe_ColorImage_AI6 get begin

% ------------------------------------------------------
% Routine Overview
% 
%	String Iterators
%		WalkRGBString (given a single source string, convert each pixel to cmyk and call a proc)
%		WalkCMYKString (given a single source string, get the components and call a proc)
% 
%	Level1 Emulator Routines
%		StuffRGBIntoGrayString
%		RGBToGrayImageProc
%		StuffCMYKIntoGrayString 
%		CMYKToGrayImageProc 
%		ColorImageCompositeEmulator 
% 
%	ColorImage CMYK Separation Hacks (For [Applications] that only support planar images)
%		CMYKToSeparatedCMYKImageProc
% 
%	ColorImage and Utility Routines.
%		FourEqual
%		TestPlateIndex
%		colorimage
% 
% ------------------------------------------------------	

/initialize
{ 
	Adobe_ColorImage_AI6 begin
	Adobe_ColorImage_AI6
	{
		dup type /arraytype eq
		{
			dup xcheck
			{
				bind
			} if
		} if
		pop pop
	} forall
} def

/terminate { end } def

currentdict /Adobe_ColorImage_AI6_Vars known not
{
	/Adobe_ColorImage_AI6_Vars 14 dict def
} if

Adobe_ColorImage_AI6_Vars begin
	/channelcount 0 def
	/sourcecount 0 def
	/sourcearray 4 array def
	/plateindex -1 def
	/XIMask 0 def
	/XIBinary 0 def
	/XIChannelCount 0 def
	/XIBitsPerPixel 0 def
	/XIImageHeight 0 def
	/XIImageWidth 0 def
	/XIImageMatrix null def
	/XIBuffer null def
	/XIDataProc null def
end

/WalkRGBString null def
/WalkCMYKString null def

/StuffRGBIntoGrayString null def
/RGBToGrayImageProc null def
/StuffCMYKIntoGrayString null def
/CMYKToGrayImageProc null def
/ColorImageCompositeEmulator null def

/SeparateCMYKImageProc null def

/FourEqual null def
/TestPlateIndex null def

% define _colorimage if it doesn't already exist
currentdict /_colorimage known not
{
	/colorimage where
	{
		% sourcedictionary (systemdict or a separation proc redefinition)
		/colorimage get /_colorimage exch def
	}
	{
		/_colorimage null def
	} ifelse
} if

/_currenttransfer systemdict /currenttransfer get def

/colorimage null def
/XI null def

% ------------------------------------------------------
% rgb proc out --WalkRGBString--
% ------------------------------------------------------

/WalkRGBString
{
	% rgb proc out
	0 3 index

	% rgb proc out outindex rgb
	dup length 1 sub 0 3 3 -1 roll
	{
		% rgb proc out outindex rgb index
		3 getinterval { } forall

		% call the stuff proc
		% rgb proc out outindex r g b
		5 index exec

		% push rgb for the next loop iteration
		% rgb proc out outindex
		3 index
		% rgb proc out outindex rgb
	} for
	
	% clean up the stack
	% rgb proc out outindex rgb
	 5 { pop } repeat

} def

% ------------------------------------------------------
% cmyk proc gray --WalkCMYKString--
% ------------------------------------------------------

/WalkCMYKString
{
	% cmyk proc gray
	0 3 index

	% cmyk proc gray grayindex cmyk
	dup length 1 sub 0 4 3 -1 roll
	{
		% cmyk proc gray grayindex cmyk index
		4 getinterval { } forall
		
		% cmyk proc gray grayindex c m y k
		6 index exec
		
		% cmyk proc gray grayindex
		3 index
		
		% cmyk proc gray grayindex cmyk
	} for
	
	% clean up the stack
	% cmyk proc gray grayindex cmyk
	5 { pop } repeat
	
} def

% ------------------------------------------------------
% gray grayindex r g b --StuffRGBIntoGrayString-- gray grayindex
% ------------------------------------------------------

/StuffRGBIntoGrayString
{
	% gray grayindex r g b
	.11 mul exch
	
	% gray grayindex r bk g
	.59 mul add exch
	
	% gray grayindex bkgk r
	.3 mul add
	
	% gray grayindex k
	cvi 3 copy put
	
	% gray grayindex k
	pop 1 add
} def

% ------------------------------------------------------
% --RGBToGrayImageProc-- string
% ------------------------------------------------------

/RGBToGrayImageProc
{	
	Adobe_ColorImage_AI6_Vars begin	
		% call the source proc to get the chunky rgb string
		sourcearray 0 get exec

		% make a grayscale string of the same pixel count (ouch, pull me out of this loop)
		% rgb
		dup length 3 idiv string

		% roll off a copy of the gray string
		% rgb gray
		dup 3 1 roll 
		
		% push the stuff proc that we want called by WalkRGBString
		% gray rgb gray
		/StuffRGBIntoGrayString load exch

		% call the rgb conversion iterator
		% gray rgb proc gray
		WalkRGBString

		% return the gray string
		% gray	
	end
} def

% ------------------------------------------------------
% gray grayindex c m y k --StuffCMYKIntoGrayString-- gray grayindex
% ------------------------------------------------------

/StuffCMYKIntoGrayString
{
	% gray grayindex c m y k
	exch .11 mul add
	
	% gray grayindex c m yk
	exch .59 mul add
	
	% gray grayindex c mkyk
	exch .3 mul add
	
	% pin k to 255
	% gray gray index k
	dup 255 gt { pop 255 } if
	
	% gray grayindex k
	255 exch sub cvi 3 copy put
	
	% gray grayindex k
	pop 1 add
} def

% ------------------------------------------------------
% --CMYKToGrayImageProc-- string
% ------------------------------------------------------

/CMYKToGrayImageProc
{	
	Adobe_ColorImage_AI6_Vars begin
		% call the source proc to get the chunky cmyk string
		sourcearray 0 get exec

		% make a grayscale string of the same pixel count (ouch, pull me out of this loop)
		% cmyk
		dup length 4 idiv string

		% roll off a copy of the gray string
		% cmyk gray
		dup 3 1 roll 
		
		% push the stuff proc that we want called by WalkCMYKString
		% gray cmyk gray
		/StuffCMYKIntoGrayString load exch

		% call the cmyk iterator
		% gray cmyk proc gray
		WalkCMYKString

		% return the gray string
		% gray
	end
} def

% ------------------------------------------------------
% width height bitsperpixel matrix firstsource...lastsource multiplesources channelcount --ColorImageCompositeEmulator--
% ------------------------------------------------------

/ColorImageCompositeEmulator
{
	% Channelcount is already saved in Adobe_ColorImage_AI6_Vars. Our data is always in chunky form so punt if someone
	% calls colorimage on a level 1 device with planar data.
	% channelcount and multiplesources are already saved in Adobe_ColorImage_AI6_Vars. The image operator isn't going to use them.
	pop true eq
	{
		% pop off the parameters and return
		Adobe_ColorImage_AI6_Vars /sourcecount get 5 add { pop } repeat
	}
	{
		Adobe_ColorImage_AI6_Vars /channelcount get 1 ne
		{
			Adobe_ColorImage_AI6_Vars begin
				% save off the original chunky source function
				sourcearray 0 3 -1 roll put
			
				% push the appropriate cover proc
				channelcount 3 eq 
				{ 
					/RGBToGrayImageProc 
				}
				{ 
					/CMYKToGrayImageProc
				} ifelse
				load
			end
		} if
		image
	} ifelse
} def

% ------------------------------------------------------
% --SeparateCMYKImageProc-- string
% ------------------------------------------------------

/SeparateCMYKImageProc
{	
	Adobe_ColorImage_AI6_Vars begin

		sourcecount 0 ne
		{
			% planar case: call the source proc for the current plate and return its result
			sourcearray plateindex get exec
		}
		{			
			% call the source proc to get the chunky cmyk string
			sourcearray 0 get exec
			
			% make a grayscale string of the same pixel count (ouch, pull me out of this loop)
			% cmyk
			dup length 4 idiv string
			
			% cmyk
			0 2 index
			
			% cmyk gray grayindex cmyk
			plateindex 4 2 index length 1 sub
			{
				% cmyk gray grayindex cmyk channelindex
				get 255 exch sub
				
				% cmyk gray grayindex grayvalue
				3 copy put pop 1 add
				
				% cmyk gray grayindex
				2 index
			} for

			% return the gray string
			% cmyk gray grayindex cmyk
			pop pop exch pop
		} ifelse
	end
} def
	
% ------------------------------------------------------
% s1 s2 s3 s4 c1 c2 c3 c4 --FourEqual--
% ------------------------------------------------------

/FourEqual
{
	% s1 s2 s3 s4 c1 c2 c3 c4
	4 index ne
	{
		pop pop pop false
	}
	{
		% s1 s2 s3 s4 c1 c2 c3
		4 index ne
		{
			pop pop false
		}
		{
			% s1 s2 s3 s4 c1 c2
			4 index ne
			{
				pop false
			}
			{
				% s1 s2 s3 s4 c1
				4 index eq
			} ifelse
		} ifelse
	} ifelse
} def

% ------------------------------------------------------
%  --TestPlateIndex-- plateindex
% ------------------------------------------------------

/TestPlateIndex
{
	Adobe_ColorImage_AI6_Vars begin
		% assume we're not separating
		/plateindex -1 def

		/setcmykcolor where
		{
			pop
			gsave
			1 0 0 0 setcmykcolor systemdict /currentgray get exec 1 exch sub
			0 1 0 0 setcmykcolor systemdict /currentgray get exec 1 exch sub
			0 0 1 0 setcmykcolor systemdict /currentgray get exec 1 exch sub
			0 0 0 1 setcmykcolor systemdict /currentgray get exec 1 exch sub
			grestore

			% cyan plate?
			1 0 0 0 FourEqual 
			{ 
				/plateindex 0 def
			}
			{
				% magenta plate?
				0 1 0 0 FourEqual
				{ 
					/plateindex 1 def
				}
				{
					% yellow plate?
					0 0 1 0 FourEqual
					{
						/plateindex 2 def
					}
					{
						% black plate
						0 0 0 1 FourEqual
						{ 
							/plateindex 3 def
						}
						{
							0 0 0 0 FourEqual
							{
								/plateindex 5 def
							} if
						} ifelse
					} ifelse
				} ifelse
			} ifelse
			pop pop pop pop
		} if
		plateindex
	end
} def

% ------------------------------------------------------
% width height bitsperpixel matrix firstsource...lastsource multiplesources channelcount --colorimage--
% ------------------------------------------------------

/colorimage
{
	Adobe_ColorImage_AI6_Vars begin
		/channelcount 1 index def
		/sourcecount 2 index 1 eq { channelcount 1 sub } { 0 } ifelse def

		% setup for following if statement
		4 sourcecount add index dup 
		8 eq exch 1 eq or not
	end
	
	% is this not 1 or 8 bit?
	{
		% Call the original proc if the image is at a weird bit depth. This will display a composite if we're separating, but too bad.
		/_colorimage load null ne
		{
			% call the original (they probably punt if we're separating)
			_colorimage
		}
		{
			% pop off the parameters and return
			Adobe_ColorImage_AI6_Vars /sourcecount get
			7 add { pop } repeat
		} ifelse
	}
	{
		% Call the saved colorimage operator if this an rgb, we're printing a composite or we're separating
		% an image to a custom plate. The last case assumes that the separation procs surrounding us
		% take care of punching out
		dup 3 eq
		TestPlateIndex
		dup -1 eq exch 5 eq or or
		{
			% Call the colorimage emulator if we're printing to a level 1 device
			/_colorimage load null eq
			{
				ColorImageCompositeEmulator
			}
			{
				% call image if this is a grayscale so that Quark doesn't die on custom plates
				dup 1 eq
				{
					pop pop image
				}
				{
					% draw to the null device if we're on a custom plate
					Adobe_ColorImage_AI6_Vars /plateindex get 5 eq
					{
						gsave
						
						% stolen from PhotoShop
						0 _currenttransfer exec
						1 _currenttransfer exec
						eq
						{ 0 _currenttransfer exec 0.5 lt }
						{ 0 _currenttransfer exec 1 _currenttransfer exec gt } ifelse
						
						% push the appropriate transfer proc (first case is negative
						% second case is positive) and call settransfer
						{ { pop 0 } } { { pop 1 } } ifelse
						systemdict /settransfer get exec
					} if
					
					_colorimage
					
					% restore from the null device if necessary
					Adobe_ColorImage_AI6_Vars /plateindex get 5 eq
					{
						grestore
					} if
				} ifelse
			} ifelse
		}
		{
			% Are we separating a grayscale image?
			dup 1 eq
			{
				% let the surrounding separation procset handle the separation
				pop pop
				image
			}
			{
				% pop channelcount and multiplesources since they're not used by the image operator
				pop pop

				% Prepare to call the image operator with a cover proc
				Adobe_ColorImage_AI6_Vars begin
					% save off the source procs for our cover proc
					% width height bitsperpixel matrix firstsource...lastsource
					sourcecount -1 0
					{			
						% width height bitsperpixel matrix firstsource...lastsource index
						exch sourcearray 3 1 roll put
					} for

					/SeparateCMYKImageProc load
				end

				% bypass the separation procset since some applications don't handle chunky and the
				% old separator doesn't handle colorimage
				systemdict /image get exec
			} ifelse
		} ifelse
	} ifelse
} def

% ------------------------------------------------------
% --XI--
% ------------------------------------------------------

/XI
{
	Adobe_ColorImage_AI6_Vars begin
		gsave
		/XIMask exch 0 ne def
		/XIBinary exch 0 ne def
		pop
		pop
		/XIChannelCount exch def
		/XIBitsPerPixel exch def
		/XIImageHeight exch def
		/XIImageWidth exch def
		pop pop pop pop
		/XIImageMatrix exch def
		
		XIBitsPerPixel 1 eq
		{
			XIImageWidth 8 div ceiling cvi
		}
		{
			XIImageWidth XIChannelCount mul
		} ifelse
		/XIBuffer exch string def
		
		XIBinary
		{
			/XIDataProc { currentfile XIBuffer readstring pop } def
			% skip the %BeginBinary comment
			currentfile 128 string readline pop pop
		}
		{
			/XIDataProc { currentfile XIBuffer readhexstring pop } def
		} ifelse
		
		0 0 moveto
		XIImageMatrix concat
		XIImageWidth XIImageHeight scale
		
		XIMask
		{
			XIImageWidth XIImageHeight
			false
			[ XIImageWidth 0 0 XIImageHeight neg 0 0 ]
			/XIDataProc load
			
			% synch the PostScript fill with Illustrator's notion of the current fill
			/_lp /null ddef
			_fc
			/_lp /imagemask ddef
			
			imagemask
		}
		{
			XIImageWidth XIImageHeight
			XIBitsPerPixel
			[ XIImageWidth 0 0 XIImageHeight neg 0 0 ]
			/XIDataProc load
			
			% call image if passed grayscale or bitmap data. Some applications
			% die if colorimage is called with gray data.
			XIChannelCount 1 eq
			{
				% Some applications refuse to separate a grayscale image to the black plate if
				% the currentgray is white. Hack around.
				
				gsave
				0 setgray
				
				image
				
				grestore
			}
			{
				false
				XIChannelCount
				colorimage
			} ifelse
		} ifelse

		grestore
	end
} def
	
end

%%EndProcSet

% ------------------------------------------------------
%%BeginResource: procset Adobe_Illustrator_AI5 1.1 0
%%Title: (Adobe Illustrator (R) Version 5.0 Full Prolog)
%%Version: 1.1 0
%%CreationDate: (3/7/1994) ()
%%Copyright: ((C) 1987-1996 Adobe Systems Incorporated All Rights Reserved)
% ------------------------------------------------------

currentpacking true setpacking

% 71 vars, but leave slack of 10 entries for custom Postscript fragments
userdict /Adobe_Illustrator_AI5_vars 81 dict dup begin
put

% paint operands
/_eo false def
/_lp /none def
/_pf
{
} def	% paint fill
/_ps
{
} def	% paint stroke
/_psf
{
} def	% paint string fill
/_pss
{
} def	% paint string stroke
/_pjsf
{
} def	% paint justified string fill
/_pjss
{
} def	% paint justified string stroke
/_pola 0 def
/_doClip 0 def

% paint operators
/cf currentflat def	% - cf flatness

% typography operands
/_tm matrix def
/_renderStart
[
/e0 /r0 /a0 /o0 /e1 /r1 /a1 /i0
] def
/_renderEnd
[
null null null null /i1 /i1 /i1 /i1
] def
/_render -1 def
/_rise 0 def
/_ax 0 def	% x character spacing	(_ax, _ay, _cx, _cy follows awidthshow naming convention)
/_ay 0 def	% y character spacing
/_cx 0 def	% x word spacing
/_cy 0 def	% y word spacing
/_leading
[
0 0
] def
/_ctm matrix def
/_mtx matrix def
/_sp 16#020 def
/_hyphen (-) def
/_fScl 0 def
/_cnt 0 def
/_hs 1 def
/_nativeEncoding 0 def
/_useNativeEncoding 0 def
/_tempEncode 0 def
/_pntr 0 def
/_tDict 2 dict def
/_wv 0 def

% typography operators
/Tx
{
} def
/Tj
{
} def

% compound path operators
/CRender
{
} def

% printing
/_AI3_savepage
{
} def

% color operands
/_gf null def
/_cf 4 array def
/_if null def
/_of false def
/_fc
{
} def
/_gs null def
/_cs 4 array def
/_is null def
/_os false def
/_sc
{
} def

% pattern operands
/_pd 1 dict def
/_ed 15 dict def
/_pm matrix def
/_fm null def
/_fd null def
/_fdd null def
/_sm null def
/_sd null def
/_sdd null def
/_i null def

% discard variables (12 total)

/discardSave null def	% holds save used in discard loop
/buffer 256 string def	% line buffer string : assume 256 chars/line
/beginString null def	% begin delimiter
/endString null def	% end delimiter
/endStringLength null def	% holds buffer size for reading by byte technique
/layerCnt 1 def	% internal variables for discard loop
/layerCount 1 def
/perCent (%) 0 get def
/perCentSeen? false def
/newBuff null def
/newBuffButFirst null def
/newBuffLast null def

% variable for doing clipping without rendering
/clipForward? false def

% end the vars dictionary
end
% =========================================


userdict /Adobe_Illustrator_AI5 known not {
	userdict /Adobe_Illustrator_AI5 91 dict put
} if

userdict /Adobe_Illustrator_AI5 get begin


% initialization
/initialize	% - initialize -
{
	% pushing main on the stack
	Adobe_Illustrator_AI5 dup begin

	% push the vars dictionary
	Adobe_Illustrator_AI5_vars begin

	% at this point the main and vars dictionaries
	% are in the state we wish them to be
	% on exit from the initialize call

	% bind the procedures in the discard dictionary
	discardDict
	{
		bind pop pop
	} forall

	% begin the nc dictionary
	dup /nc get begin

	% bind the procs in main
	{
		% added a test for type = operatortype so procedures like Ln can be defined as an alias for 'pop
		dup xcheck 1 index type /operatortype ne and
		{
			bind
		} if
		pop pop
	} forall

	% turn off 'nc
	end

	newpath

	% on exit we have main and vars on top of dict stack
} def

/terminate	% - terminate -
{
	end
	end
} def

% definition operators
/_	% - _ null
null def
/ddef	% key value ddef -
{
	Adobe_Illustrator_AI5_vars 3 1 roll put
} def
/xput	% key value literal xput -
{
	dup load dup length exch maxlength eq
	{
		dup dup load dup
		length 2 mul dict copy def
	} if
	load begin
	def
	end
} def
/npop	% integer npop -
{
	{
		pop
	} repeat
} def

% marking operators
/sw	% ax ay string sw x y
{
	dup length exch stringwidth
	exch 5 -1 roll 3 index mul add
	4 1 roll 3 1 roll mul add
} def
/swj	% cx cy fillchar ax ay string swj x y
{
	dup 4 1 roll
	dup length exch stringwidth
	exch 5 -1 roll 3 index mul add
	4 1 roll 3 1 roll mul add
	6 2 roll /_cnt 0 ddef
	{
		1 index eq
		{
			/_cnt _cnt 1 add ddef
		} if
	} forall
	pop
	exch _cnt mul exch _cnt mul 2 index add 4 1 roll 2 index add 4 1 roll pop pop
} def
/ss	% ax ay string matrix ss -
{
	4 1 roll
	{
		% matrix ax ay char 0 0 {proc} -
		2 npop
		(0) exch 2 copy 0 exch put pop
		gsave
		false charpath currentpoint
		4 index setmatrix
		stroke
		grestore
		moveto
		2 copy rmoveto
	} exch cshow
	3 npop
} def
/jss	% cx cy fillchar ax ay string matrix jss -
{
	4 1 roll
	{
		% cx cy fillchar matrix ax ay char 0 0 {proc} -   
		2 npop
		(0) exch 2 copy 0 exch put
		gsave
		_sp eq
		{
			exch 6 index 6 index 6 index 5 -1 roll widthshow
			currentpoint
		}
		{
			false charpath currentpoint
			4 index setmatrix stroke
		} ifelse
		grestore
		moveto
		2 copy rmoveto
	} exch cshow
	6 npop
} def

% path operators
/sp	% ax ay string sp -
{
	{
		2 npop (0) exch
		2 copy 0 exch put pop
		false charpath
		2 copy rmoveto
	} exch cshow
	2 npop
} def
/jsp	% cx cy fillchar ax ay string jsp -
{
	{
		% cx cy fillchar ax ay char 0 0 {proc} -
		2 npop
		(0) exch 2 copy 0 exch put
		_sp eq
		{
			exch 5 index 5 index 5 index 5 -1 roll widthshow
		}
		{
			false charpath
		} ifelse
		2 copy rmoveto
	} exch cshow
	5 npop
} def

% path construction operators
/pl	% x y pl x y
{
	transform
	0.25 sub round 0.25 add exch
	0.25 sub round 0.25 add exch
	itransform
} def

/setstrokeadjust where
{
	pop true setstrokeadjust
	/c	% x1 y1 x2 y2 x3 y3 c -
	{
		curveto
	} def
	/C
	/c load def
	/v	% x2 y2 x3 y3 v -
	{
		currentpoint 6 2 roll curveto
	} def
	/V
	/v load def
	/y	% x1 y1 x2 y2 y -
	{
		2 copy curveto
	} def
	/Y
	/y load def
	/l	% x y l -
	{
		lineto
	} def
	/L
	/l load def
	/m	% x y m -
	{
		moveto
	} def
}
{
	% else
	/c
	{
		pl curveto
	} def
	/C
	/c load def
	/v
	{
		currentpoint 6 2 roll pl curveto
	} def
	/V
	/v load def
	/y
	{
		pl 2 copy curveto
	} def
	/Y
	/y load def
	/l
	{
		pl lineto
	} def
	/L
	/l load def
	/m
	{
		pl moveto
	} def
} ifelse

% graphic state operators
/d	% array phase d -
{
	setdash
} def
/cf
{
} def	% - cf flatness
/i	% flatness i -
{
	dup 0 eq
	{
		pop cf
	} if
	setflat
} def
/j	% linejoin j -
{
	setlinejoin
} def
/J	% linecap J -
{
	setlinecap
} def
/M	% miterlimit M -
{
	setmiterlimit
} def
/w	% linewidth w -
{
	setlinewidth
} def

% path painting operators
/XR	% flag XR -
{
	0 ne
	/_eo exch ddef
} def
/H	% - H -
{
} def
/h	% - h -
{
	closepath
} def
/N	% - N -
{
	_pola 0 eq
	{
		_doClip 1 eq
		{
			_eo {eoclip} {clip} ifelse /_doClip 0 ddef
		} if
		newpath
	}
	{
		/CRender
		{
			N
		} ddef
	} ifelse
} def
/n	% - n -
{
	N
} def
/F	% - F -
{
	_pola 0 eq
	{
		_doClip 1 eq
		{
			gsave _pf grestore _eo {eoclip} {clip} ifelse newpath /_lp /none ddef _fc
			/_doClip 0 ddef
		}
		{
			_pf
		} ifelse
	}
	{
		/CRender
		{
			F
		} ddef
	} ifelse
} def
/f	% - f -
{
	closepath
	F
} def
/S	% - S -
{
	_pola 0 eq
	{
		_doClip 1 eq
		{
			gsave _ps grestore _eo {eoclip} {clip} ifelse newpath /_lp /none ddef _sc
			/_doClip 0 ddef
		}
		{
			_ps
		} ifelse
	}
	{
		/CRender
		{
			S
		} ddef
	} ifelse
} def
/s	% - s -
{
	closepath
	S
} def
/B	% - B -
{
	_pola 0 eq
	{
		_doClip 1 eq	% F clears _doClip
		gsave F grestore
		{
			gsave S grestore _eo {eoclip} {clip} ifelse newpath /_lp /none ddef _sc
			/_doClip 0 ddef
		}
		{
			S
		} ifelse
	}
	{
		/CRender
		{
			B
		} ddef
	} ifelse
} def
/b	% - b -
{
	closepath
	B
} def
/W	% - W -
{
	/_doClip 1 ddef
} def
/*	% - [string] * -
{
	count 0 ne
	{
		dup type /stringtype eq
		{
			pop
		} if
	} if
	% used to call newpath only if _polo was 0; now newpath is called unconditionally (bh 3/24/94)
	newpath
} def

% group operators
/u	% - u -
{
} def
/U	% - U -
{
} def
/q	% - q -
{
	_pola 0 eq
	{
		gsave
	} if
} def
/Q	% - Q -
{
	_pola 0 eq
	{
		grestore
	} if
} def
/*u	% - *u -
{
	_pola 1 add /_pola exch ddef
} def
/*U	% - *U -
{
	_pola 1 sub /_pola exch ddef
	_pola 0 eq
	{
		CRender
	} if
} def
/D	% polarized D -
{
	pop
} def
/*w	% - *w -
{
} def
/*W	% - *W -
{
} def

% place operators
/`	% matrix llx lly urx ury string ` -
{
	/_i save ddef

% * special case of clipping forward without rendering
	% use 'nulldevice if true
	clipForward?
	{
		nulldevice
	} if

	6 1 roll 4 npop
	concat pop
	userdict begin
	/showpage
	{
	} def
	0 setgray
	0 setlinecap
	1 setlinewidth
	0 setlinejoin
	10 setmiterlimit
	[] 0 setdash
	/setstrokeadjust where {pop false setstrokeadjust} if
	newpath
	0 setgray
	false setoverprint
} def
/~	% - ~ -
{
	end
	_i restore
} def

% color operators
/O	% flag O -
{
	0 ne
	/_of exch ddef
	/_lp /none ddef
} def
/R	% flag R -
{
	0 ne
	/_os exch ddef
	/_lp /none ddef
} def
/g	% gray g -
{
	/_gf exch ddef
	/_fc
	{
		_lp /fill ne
		{
			_of setoverprint
			_gf setgray
			/_lp /fill ddef
		} if
	} ddef
	/_pf
	{
		_fc
		_eo {eofill} {fill} ifelse
	} ddef
	/_psf
	{
		_fc
		ashow
	} ddef
	/_pjsf
	{
		_fc
		awidthshow
	} ddef
	/_lp /none ddef
} def
/G	% gray G -
{
	/_gs exch ddef
	/_sc
	{
		_lp /stroke ne
		{
			_os setoverprint
			_gs setgray
			/_lp /stroke ddef
		} if
	} ddef
	/_ps
	{
		_sc
		stroke
	} ddef
	/_pss
	{
		_sc
		ss
	} ddef
	/_pjss
	{
		_sc
		jss
	} ddef
	/_lp /none ddef
} def
/k	% cyan magenta yellow black k -
{
	_cf astore pop
	/_fc
	{
		_lp /fill ne
		{
			_of setoverprint
			_cf aload pop setcmykcolor
			/_lp /fill ddef
		} if
	} ddef
	/_pf
	{
		_fc
		_eo {eofill} {fill} ifelse
	} ddef
	/_psf
	{
		_fc
		ashow
	} ddef
	/_pjsf
	{
		_fc
		awidthshow
	} ddef
	/_lp /none ddef
} def
/K	% cyan magenta yellow black K -
{
	_cs astore pop
	/_sc
	{
		_lp /stroke ne
		{
			_os setoverprint
			_cs aload pop setcmykcolor
			/_lp /stroke ddef
		} if
	} ddef
	/_ps
	{
		_sc
		stroke
	} ddef
	/_pss
	{
		_sc
		ss
	} ddef
	/_pjss
	{
		_sc
		jss
	} ddef
	/_lp /none ddef
} def
/x	% cyan magenta yellow black name gray x -
{
	/_gf exch ddef
	findcmykcustomcolor
	/_if exch ddef
	/_fc
	{
		_lp /fill ne
		{
			_of setoverprint
			_if _gf 1 exch sub setcustomcolor
			/_lp /fill ddef
		} if
	} ddef
	/_pf
	{
		_fc
		_eo {eofill} {fill} ifelse
	} ddef
	/_psf
	{
		_fc
		ashow
	} ddef
	/_pjsf
	{
		_fc
		awidthshow
	} ddef
	/_lp /none ddef
} def
/X	% cyan magenta yellow black name gray X -
{
	/_gs exch ddef
	findcmykcustomcolor
	/_is exch ddef
	/_sc
	{
		_lp /stroke ne
		{
			_os setoverprint
			_is _gs 1 exch sub setcustomcolor
			/_lp /stroke ddef
		} if
	} ddef
	/_ps
	{
		_sc
		stroke
	} ddef
	/_pss
	{
		_sc
		ss
	} ddef
	/_pjss
	{
		_sc
		jss
	} ddef
	/_lp /none ddef
} def

% locked object operator
/A	% value A -
{
	pop
} def

% annotate page operator
/annotatepage
{
userdict /annotatepage 2 copy known {get exec} {pop pop} ifelse
} def



% object tag operator
% joe holt November 20, 1994

% /name (value) XT
/XT {
	pop pop
} def


% begin layer PostScript implementation

% general purpose discard loop
% works on early level 1 (v.23, v.38) PostScript printers
% version 0.02 04/03/93
% Bill Woodruff

% constraints :

% if nested discards must be handled
% then the begin and end delimiting
% strings must be of equal length

% arguments

% #nestingFlag
% #nestingFlag = 0  				no nesting
% #nestingFlag = 1  				nesting

% non-nested case
% note : since the non-nested case is invoked
% after the ocurrence of a beginning string
% we only have to look for the ending string
% it is not necessary to specify a beginning string

% 0 (endString) 

% nested case

% (beginString) 1 (endString) 

% the discard procedure is defined in the main dictionary
% it turns the discard dictionary on to execute the discard function
/discard
{
	% test for version, hash a key
	% get and execute the discard procedure from dictionary
	% execute it in a stopped context so we can bail with 'stop
	% wrap it in a save so we don't have to reset variables
	save /discardSave exch store
	discardDict begin
	/endString exch store
	gt38?
	{
		2 add
	} if
	load
	stopped
	pop
	end
	discardSave restore
} bind def

% build the discard dictionary which will contain only procedures
userdict /discardDict 7 dict dup begin
put

% pre 38 initialization
/pre38Initialize
{
	% used as buffer size for reading by byte technique	
	/endStringLength endString length store

	/newBuff buffer 0 endStringLength getinterval store	%	new buffer equal in length to end string
	/newBuffButFirst newBuff 1 endStringLength 1 sub getinterval store	%	pointer to from 2nd to last char in new buffer
	/newBuffLast newBuff endStringLength 1 sub 1 getinterval store	%	pointer to last char in new buffer
} def

% for <=38	
/shiftBuffer
{
	% shift last chars of newBuff to start of newBuff
	newBuff 0 newBuffButFirst putinterval
	% new character into last byte of newBuff
	newBuffLast 0
	currentfile read not
	{
	stop
	} if
	put
} def

% discard procedures

% no nesting, older ps
0
{
	pre38Initialize
	mark
	% fill the buffer
	currentfile newBuff readstring exch pop
	{
		{
			newBuff endString eq
			{
				cleartomark stop
			} if
			shiftBuffer
		} loop
	}
	{
	stop
	} ifelse
} def

% nesting, older ps
1
{
	pre38Initialize

	/beginString exch store

	mark
	currentfile newBuff readstring exch pop
	{
		{
			newBuff beginString eq
			{
				/layerCount dup load 1 add store
			}
			{
				newBuff endString eq
				{
					/layerCount dup load 1 sub store
					layerCount 0 eq
					{
						cleartomark stop
					} if
				} if
			} ifelse

			shiftBuffer
		} loop
	} if
} def

% no nesting, newer ps
2
{
	mark
	{
		% read a line : exit if end of file reached
		currentfile buffer readline not
		{
		stop
		} if

		% end of layer ?
		endString eq
		{
			cleartomark stop
		} if
	} loop
} def

% nesting, newer ps
3
{
	/beginString exch store
	/layerCnt 1 store
	mark
	{
		% read a line : exit if end of file reached
		currentfile buffer readline not
		{
		stop
		} if

		% start of layer ?
		dup beginString eq
		{
			% update layer counter
			pop /layerCnt dup load 1 add store
		}
		{
			% end of layer ?
			endString eq
			{
				% stop if we're not nested
				layerCnt 1 eq
				{
					cleartomark stop
				}
				{
					% nested : decrement layer counter
					/layerCnt dup load 1 sub store
				} ifelse
			} if
		} ifelse
	} loop
} def

% end discard dictionary
end

% define the dictionary for clipping without rendering

userdict /clipRenderOff 15 dict dup begin
put

% flag for marking this dictionary as active
% so we can test in /` and wrap placed
% elements in nulldevice
% /clipForward? true def

% re-define rendering primitives to clip and newpath
% based on value of /_doClip flag
{
	/n /N /s /S /f /F /b /B
}
{
	{
		_doClip 1 eq
		{
			/_doClip 0 ddef _eo {eoclip} {clip} ifelse
		} if
		newpath
	} def
} forall

% modify 'Tr so Tj and Tx are never set up by
% the calls to 'a0, 'e0, etc.
/Tr /pop load def

% special case of 'cshow ?
% is so, we'll have to overload toplevels
% /patternashow /patternawidthshow
% /patternashowstroke
% /patternawidthshowstroke
% /ss /jss /sp /jsp

% perhaps we can bracket out patterns at a higher level ?
% for example, by modifying 'E to pop off its parameters

% call to 'show in 'patternpath ?
% calls to 'ashow in '_psf ?
% calls to 'awidthshow in '_pjsf ?
% calls to 'widthshow in '_jss and '_jsp ?

% disable gradient operators
/Bb {} def
/BB /pop load def
/Bg {12 npop} def
/Bm {6 npop} def
/Bc /Bm load def
/Bh {4 npop} def

% end dictionary for clipping without rendering
end

/Lb	% visible preview enabled printing dimmed masks colorIndex red green blue  ==> Lb
{
	4 npop
	6 1 roll
	pop
	4 1 roll
	pop pop pop

	% #masks #printing 

	% assume that
	% masks = 1 masks forward, masks = 0 no masking or only local masking	

	% do the right thing for printing and masking layer
	0 eq
	{
		% non-printing layer

		0 eq
		{
			% no masking forward from this layer
			% nested discard call
			(%AI5_BeginLayer) 1 (%AI5_EndLayer--) discard
		}
		{
			% masking forward from this layer
			% no printing, but clip path must survive
			
			% set the clipForward? flag in the vars dict
			/clipForward? true def
			
			% redefine Tx and Tj in the vars dict
			/Tx /pop load def
			/Tj /pop load def
			
			% turn on the no rendering dictionary
			currentdict end clipRenderOff begin begin
		} ifelse
	}
	{
		% printing layer

		% encapsulate layer with 'save
		% only if there is no masking forward

		0 eq
		{
			save /discardSave exch store
		} if
	} ifelse
} bind def

% end layer :
% assume that if discardSave is non-null
% then the layer was bracketed by 'save...restore
% else we must test for clipping forward
/LB	% ==> Lb ==> .....
{
	discardSave dup null ne
	{
		% undo the save
		restore
	}
	{
		pop

		clipForward?
		{
			% assume dictionary stack :

			%		vars			
			%		clipRenderOff			
			%		main

			currentdict
			end
			end
			begin

			% dictionary stack :

			%		vars			
			%		main
					
			/clipForward? false ddef

		} if
	} ifelse
} bind def

% begin palette discard
% assume no nesting
/Pb	% topLeftCell selected Pb -
{
	pop pop
	% non nested discard
	0 (%AI5_EndPalette) discard
} bind def

% other type of discard
% assume no nesting
/Np
{
	0 (%AI5_End_NonPrinting--) discard
} bind def

% express layer name
/Ln /pop load def	% ==> Ln ==> .....

% path center-point flag operator
/Ap	% value Ap -
/pop load def

% device-independent flatness
/Ar
{
	72 exch div
	0 dtransform dup mul exch dup mul add sqrt
	dup 1 lt
	{
		pop 1
	} if
	setflat
} def

% multi-layer clipping
/Mb
{
	q
} def
/Md
{
} def
/MB
{
	Q
} def

% null color operators
/nc 3 dict def
nc begin
/setgray	% gray setgray -
{
	pop
} bind def
/setcmykcolor	% cyan magenta yellow black setcmykcolor -
{
	4 npop
} bind def
/setcustomcolor	% object tint setcustomcolor -
{
	2 npop
} bind def
% exit 'nc dictionary
currentdict readonly pop
end

% exit main dictionary
% currentdict readonly pop
end
setpacking

%%EndResource
%%EndProlog
%%BeginSetup
Adobe_level2_AI5 /initialize get exec
Adobe_ColorImage_AI6 /initialize get exec
Adobe_Illustrator_AI5 /initialize get exec
%AI5_Begin_NonPrinting
Np
%AI3_BeginPattern: (Yellow Stripe)
(Yellow Stripe) 8.4499 4.6 80.4499 76.6 [
%AI3_Tile
(0 O 0 R 0 0.4 1 0 k 0 0.4 1 0 K) @
(
%AI6_BeginPatternLayer
800 Ar
0 J 0 j 3.6 w 4 M []0 d
%AI3_Note:
0 D
0 XR
8.1999 8.1999 m
80.6999 8.1999 L
S
8.1999 22.6 m
80.6999 22.6 L
S
8.1999 37.0001 m
80.6999 37.0001 L
S
8.1999 51.3999 m
80.6999 51.3999 L
S
8.1999 65.8 m
80.6999 65.8 L
S
8.1999 15.3999 m
80.6999 15.3999 L
S
8.1999 29.8 m
80.6999 29.8 L
S
8.1999 44.1999 m
80.6999 44.1999 L
S
8.1999 58.6 m
80.6999 58.6 L
S
8.1999 73.0001 m
80.6999 73.0001 L
S
%AI6_EndPatternLayer
) &
] E
%AI3_EndPattern
%AI5_End_NonPrinting--
%AI5_Begin_NonPrinting
Np
3 Bn
%AI5_BeginGradient: (Black & White)
(Black & White) 0 2 Bd
[
<
FFFEFDFCFBFAF9F8F7F6F5F4F3F2F1F0EFEEEDECEBEAE9E8E7E6E5E4E3E2E1E0DFDEDDDCDBDAD9D8
D7D6D5D4D3D2D1D0CFCECDCCCBCAC9C8C7C6C5C4C3C2C1C0BFBEBDBCBBBAB9B8B7B6B5B4B3B2B1B0
AFAEADACABAAA9A8A7A6A5A4A3A2A1A09F9E9D9C9B9A999897969594939291908F8E8D8C8B8A8988
87868584838281807F7E7D7C7B7A797877767574737271706F6E6D6C6B6A69686766656463626160
5F5E5D5C5B5A595857565554535251504F4E4D4C4B4A494847464544434241403F3E3D3C3B3A3938
37363534333231302F2E2D2C2B2A292827262524232221201F1E1D1C1B1A19181716151413121110
0F0E0D0C0B0A09080706050403020100
>
0 %_Br
[
0 0 50 100 %_Bs
1 0 50 0 %_Bs
BD
%AI5_EndGradient
%AI5_BeginGradient: (Red & Yellow)
(Red & Yellow) 0 2 Bd
[
0
<
000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F2021222324252627
28292A2B2C2D2E2F303132333435363738393A3B3C3D3E3F404142434445464748494A4B4C4D4E4F
505152535455565758595A5B5C5D5E5F606162636465666768696A6B6C6D6E6F7071727374757677
78797A7B7C7D7E7F808182838485868788898A8B8C8D8E8F909192939495969798999A9B9C9D9E9F
A0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBEBFC0C1C2C3C4C5C6C7
C8C9CACBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDDEDFE0E1E2E3E4E5E6E7E8E9EAEBECEDEEEF
F0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF
>
<
FFFFFEFEFDFDFDFCFCFBFBFBFAFAF9F9F9F8F8F7F7F7F6F6F5F5F5F4F4F3F3F3F2F2F1F1F1F0F0EF
EFEFEEEEEDEDEDECECEBEBEBEAEAE9E9E9E8E8E7E7E7E6E6E5E5E5E4E4E3E3E3E2E2E1E1E1E0E0DF
DFDFDEDEDDDDDDDCDCDBDBDBDADAD9D9D9D8D8D7D7D7D6D6D5D5D5D4D4D3D3D3D2D2D1D1D1D0D0CF
CFCFCECECDCDCDCCCCCBCBCBCACAC9C9C9C8C8C7C7C7C6C6C5C5C5C4C4C3C3C3C2C2C1C1C1C0C0BF
BFBFBEBEBDBDBDBCBCBBBBBBBABAB9B9B9B8B8B7B7B7B6B6B5B5B5B4B4B3B3B3B2B2B1B1B1B0B0AF
AFAFAEAEADADADACACABABABAAAAA9A9A9A8A8A7A7A7A6A6A5A5A5A4A4A3A3A3A2A2A1A1A1A0A09F
9F9F9E9E9D9D9D9C9C9B9B9B9A9A9999
>
0
1 %_Br
[
0 1 0.6 0 1 50 100 %_Bs
0 0 1 0 1 50 0 %_Bs
BD
%AI5_EndGradient
%AI5_BeginGradient: (Yellow & Blue Radial)
(Yellow & Blue Radial) 1 2 Bd
[
<
000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F2021222324252627
28292A2B2C2D2E2F303132333435363738393A3B3C3D3E3F404142434445464748494A4B4C4D4E4F
505152535455565758595A5B5C5D5E5F606162636465666768696A6B6C6D6E6F7071727374757677
78797A7B7C7D7E7F808182838485868788898A8B8C8D8E8F909192939495969798999A9B9C9D9E9F
A0A1A2A3A4A5A6A7A8A9AAABACADAEAFB0B1B2B3B4B5B6B7B8B9BABBBCBDBEBFC0C1C2C3C4C5C6C7
C8C9CACBCCCDCECFD0D1D2D3D4D5D6D7D8D9DADBDCDDDEDFE0E1E2E3E4E5E6E7E8E9EAEBECEDEEEF
F0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF
>
<
1415161718191A1B1C1D1E1F1F202122232425262728292A2A2B2C2D2E2F30313233343536363738
393A3B3C3D3E3F40414142434445464748494A4B4C4D4D4E4F50515253545556575858595A5B5C5D
5E5F60616263646465666768696A6B6C6D6E6F6F707172737475767778797A7B7B7C7D7E7F808182
83848586868788898A8B8C8D8E8F90919292939495969798999A9B9C9D9D9E9FA0A1A2A3A4A5A6A7
A8A9A9AAABACADAEAFB0B1B2B3B4B4B5B6B7B8B9BABBBCBDBEBFC0C0C1C2C3C4C5C6C7C8C9CACBCB
CCCDCECFD0D1D2D3D4D5D6D7D7D8D9DADBDCDDDEDFE0E1E2E2E3E4E5E6E7E8E9EAEBECEDEEEEEFF0
F1F2F3F4F5F6F7F8F9F9FAFBFCFDFEFF
>
<
ABAAAAA9A8A7A7A6A5A5A4A3A3A2A1A1A09F9F9E9D9D9C9B9B9A9999989797969595949393929191
908F8F8E8D8D8C8B8B8A8989888787868585848383828181807F7F7E7D7D7C7B7B7A797978777776
7575747373727171706F6F6E6D6D6C6B6B6A6969686767666565646362626160605F5E5E5D5C5C5B
5A5A5958585756565554545352525150504F4E4E4D4C4C4B4A4A4948484746464544444342424140
403F3E3E3D3C3C3B3A3A3938383736363534343332323130302F2E2E2D2C2C2B2A2A292828272626
25242423222121201F1F1E1D1D1C1B1B1A1919181717161515141313121111100F0F0E0D0D0C0B0B
0A090908070706050504030302010100
>
0
1 %_Br
[
0 0.08 0.67 0 1 50 14 %_Bs
1 1 0 0 1 50 100 %_Bs
BD
%AI5_EndGradient
%AI5_End_NonPrinting--
%AI5_BeginPalette
0 0 Pb
Pn
Pc
1 g
Pc
0 g
Pc
0 0 0 0 k
Pc
0.75 g
Pc
0.5 g
Pc
0.25 g
Pc
0 g
Pc
Bb
2 (Black & White) -4014 4716 0 0 1 0 0 1 0 0 Bg
0 BB
Pc
0.25 0 0 0 k
Pc
0.5 0 0 0 k
Pc
0.75 0 0 0 k
Pc
1 0 0 0 k
Pc
0.25 0.25 0 0 k
Pc
0.5 0.5 0 0 k
Pc
0.75 0.75 0 0 k
Pc
1 1 0 0 k
Pc
Bb
2 (Red & Yellow) -4014 4716 0 0 1 0 0 1 0 0 Bg
0 BB
Pc
0 0.25 0 0 k
Pc
0 0.5 0 0 k
Pc
0 0.75 0 0 k
Pc
0 1 0 0 k
Pc
0 0.25 0.25 0 k
Pc
0 0.5 0.5 0 k
Pc
0 0.75 0.75 0 k
Pc
0 1 1 0 k
Pc
Bb
0 0 0 0 Bh
2 (Yellow & Blue Radial) -4014 4716 0 0 1 0 0 1 0 0 Bg
0 BB
Pc
0 0 0.25 0 k
Pc
0 0 0.5 0 k
Pc
0 0 0.75 0 k
Pc
0 0 1 0 k
Pc
0.25 0 0.25 0 k
Pc
0.5 0 0.5 0 k
Pc
0.75 0 0.75 0 k
Pc
1 0 1 0 k
Pc
(Yellow Stripe) 0 0 1 1 0 0 0 0 0 [1 0 0 1 0 0] p
Pc
0.25 0.125 0 0 k
Pc
0.5 0.25 0 0 k
Pc
0.75 0.375 0 0 k
Pc
1 0.5 0 0 k
Pc
0.125 0.25 0 0 k
Pc
0.25 0.5 0 0 k
Pc
0.375 0.75 0 0 k
Pc
0.5 1 0 0 k
Pc
0 0 0 0 k
Pc
0 0.25 0.125 0 k
Pc
0 0.5 0.25 0 k
Pc
0 0.75 0.375 0 k
Pc
0 1 0.5 0 k
Pc
0 0.125 0.25 0 k
Pc
0 0.25 0.5 0 k
Pc
0 0.375 0.75 0 k
Pc
0 0.5 1 0 k
Pc
0 0 0 0 k
Pc
0.125 0 0.25 0 k
Pc
0.25 0 0.5 0 k
Pc
0.375 0 0.75 0 k
Pc
0.5 0 1 0 k
Pc
0.25 0 0.125 0 k
Pc
0.5 0 0.25 0 k
Pc
0.75 0 0.375 0 k
Pc
1 0 0.5 0 k
Pc
0 0 0 0 k
Pc
0.25 0.125 0.125 0 k
Pc
0.5 0.25 0.25 0 k
Pc
0.75 0.375 0.375 0 k
Pc
1 0.5 0.5 0 k
Pc
0.25 0.25 0.125 0 k
Pc
0.5 0.5 0.25 0 k
Pc
0.75 0.75 0.375 0 k
Pc
1 1 0.5 0 k
Pc
0 0 0 0 k
Pc
0.125 0.25 0.125 0 k
Pc
0.25 0.5 0.25 0 k
Pc
0.375 0.75 0.375 0 k
Pc
0.5 1 0.5 0 k
Pc
0.125 0.25 0.25 0 k
Pc
0.25 0.5 0.5 0 k
Pc
0.375 0.75 0.75 0 k
Pc
0.5 1 1 0 k
Pc
0 0 0 0 k
Pc
0.125 0.125 0.25 0 k
Pc
0.25 0.25 0.5 0 k
Pc
0.375 0.375 0.75 0 k
Pc
0.5 0.5 1 0 k
Pc
0.25 0.125 0.25 0 k
Pc
0.5 0.25 0.5 0 k
Pc
0.75 0.375 0.75 0 k
Pc
1 0.5 1 0 k
Pc
PB
%AI5_EndPalette
%%EndSetup
%AI5_BeginLayer
1 1 1 1 0 0 0 79 128 255 Lb
(Layer 1) Ln
0 A
u
0 O
0 g
800 Ar
0 J 0 j 1 w 4 M []0 d
%AI3_Note:
0 D
0 XR
307.5226 418.1163 m
303.2469 425.4221 L
311.7982 425.4223 L
307.5226 418.1163 L
f
U
u
316.9748 418.1163 m
312.6991 425.4221 L
321.2503 425.4223 L
316.9748 418.1163 L
f
U
u
312.2483 433.6999 m
316.5242 426.3942 L
307.973 426.3938 L
312.2483 433.6999 L
f
U
*u
371.0887 426.2844 m
374.1518 426.2844 L
374.1518 424.9776 L
371.0887 424.9776 L
371.0887 426.2844 l
f
*U
*u
326.5319 430.355 m
328.1703 430.355 L
330.8873 422.7066 L
329.2286 422.7066 L
328.679 424.4098 L
325.962 424.4098 L
325.3921 422.7066 L
323.7741 422.7066 L
326.5319 430.355 l
f
1 D
326.3792 425.6632 m
328.2618 425.6632 L
327.346 428.4696 L
327.3256 428.4696 L
326.3792 425.6632 l
f
*U
*u
0 D
331.5164 430.355 m
334.6508 430.355 L
336.5333 430.355 337.9479 429.1124 337.9479 426.5736 c
337.9479 424.3562 336.8691 422.7066 334.6508 422.7066 c
331.5164 422.7066 L
331.5164 430.355 l
f
1 D
333.1142 424.1205 m
334.5388 424.1205 L
335.4649 424.1205 336.3502 424.7205 336.3502 426.413 c
336.3502 427.9555 335.8414 428.941 334.2539 428.941 c
333.1142 428.941 L
333.1142 424.1205 l
f
*U
*u
0 D
339.0569 430.355 m
342.1911 430.355 L
344.0738 430.355 345.4882 429.1124 345.4882 426.5736 c
345.4882 424.3562 344.4096 422.7066 342.1911 422.7066 c
339.0569 422.7066 L
339.0569 430.355 l
f
1 D
340.6545 424.1205 m
342.0792 424.1205 L
343.0053 424.1205 343.8906 424.7205 343.8906 426.413 c
343.8906 427.9555 343.3818 428.941 341.7943 428.941 c
340.6545 428.941 L
340.6545 424.1205 l
f
*U
*u
0 D
346.5973 430.355 m
348.195 430.355 L
348.195 422.7066 L
346.5973 422.7066 L
346.5973 430.355 l
f
*U
*u
350.6874 425.2454 m
350.6874 424.2277 351.4405 423.8313 352.2953 423.8313 c
352.8549 423.8313 353.7098 424.0027 353.7098 424.7847 c
353.7098 425.6095 352.6209 425.7488 351.5525 426.0487 c
350.4738 426.3487 349.3849 426.7879 349.3849 428.2233 c
349.3849 429.7872 350.7892 430.5371 352.1019 430.5371 c
353.6182 430.5371 355.0124 429.8408 355.0124 428.0733 c
353.4656 428.0733 L
353.4146 428.9945 352.7939 429.2302 352.0307 429.2302 c
351.5219 429.2302 350.9317 429.0053 350.9317 428.3625 c
350.9317 427.7734 351.2777 427.6984 353.0992 427.2057 c
353.6284 427.0664 355.2565 426.7129 355.2565 424.9776 c
355.2565 423.5743 354.2085 422.5244 352.2343 422.5244 c
350.6264 422.5244 349.1203 423.36 349.1407 425.2454 C
350.6874 425.2454 l
f
*U
*u
359.4588 430.5371 m
361.7078 430.5371 363.0307 428.7696 363.0307 426.4986 c
363.0307 424.292 361.7078 422.5244 359.4588 422.5244 c
357.2098 422.5244 355.8869 424.292 355.8869 426.4986 c
355.8869 428.7696 357.2098 430.5371 359.4588 430.5371 c
f
1 D
359.4588 423.9385 m
360.8936 423.9385 361.4329 425.2239 361.4329 426.4986 c
361.4329 427.8376 360.8936 429.1231 359.4588 429.1231 c
358.024 429.1231 357.4845 427.8376 357.4845 426.4986 c
357.4845 425.2239 358.024 423.9385 359.4588 423.9385 c
f
*U
*u
0 D
364.1179 430.355 m
365.7055 430.355 L
368.7379 425.2239 L
368.7583 425.2239 L
368.7583 430.355 L
370.2543 430.355 L
370.2543 422.7066 L
368.6565 422.7066 L
365.6342 427.827 L
365.6138 427.827 L
365.6138 422.7066 L
364.1179 422.7066 L
364.1179 430.355 l
f
*U
*u
381.9062 422.7066 m
380.3187 422.7066 L
379.0874 427.9126 L
379.067 427.9126 L
377.856 422.7066 L
376.238 422.7066 L
374.3147 430.355 L
375.9124 430.355 L
377.0623 425.1489 L
377.0827 425.1489 L
378.3445 430.355 L
379.8404 430.355 L
381.082 425.0846 L
381.1022 425.0846 L
382.2929 430.355 L
383.86 430.355 L
381.9062 422.7066 l
f
*U
*u
384.5914 430.355 m
390.0254 430.355 L
390.0254 428.941 L
386.189 428.941 L
386.189 427.3021 L
389.71 427.3021 L
389.71 425.9952 L
386.189 425.9952 L
386.189 424.1205 L
390.1069 424.1205 L
390.1069 422.7066 L
384.5914 422.7066 L
384.5914 430.355 l
f
*U
*u
392.274 425.2454 m
392.274 424.2277 393.0271 423.8313 393.8819 423.8313 c
394.4415 423.8313 395.2963 424.0027 395.2963 424.7847 c
395.2963 425.6095 394.2075 425.7488 393.139 426.0487 c
392.0604 426.3487 390.9715 426.7879 390.9715 428.2233 c
390.9715 429.7872 392.3758 430.5371 393.6885 430.5371 c
395.2048 430.5371 396.5989 429.8408 396.5989 428.0733 c
395.0522 428.0733 L
395.0013 428.9945 394.3805 429.2302 393.6174 429.2302 c
393.1085 429.2302 392.5183 429.0053 392.5183 428.3625 c
392.5183 427.7734 392.8643 427.6984 394.6858 427.2057 c
395.215 427.0664 396.8432 426.7129 396.8432 424.9776 c
396.8432 423.5743 395.7951 422.5244 393.8209 422.5244 c
392.213 422.5244 390.7069 423.36 390.7273 425.2454 C
392.274 425.2454 l
f
*U
*u
397.7889 430.355 m
399.3867 430.355 L
399.3867 424.1205 L
402.928 424.1205 L
402.928 422.7066 L
397.7889 422.7066 L
397.7889 430.355 l
f
*U
*u
403.8213 430.355 m
409.2554 430.355 L
409.2554 428.941 L
405.419 428.941 L
405.419 427.3021 L
408.94 427.3021 L
408.94 425.9952 L
405.419 425.9952 L
405.419 424.1205 L
409.3368 424.1205 L
409.3368 422.7066 L
403.8213 422.7066 L
403.8213 430.355 l
f
*U
*u
412.2977 425.6845 m
409.6214 430.355 L
411.4226 430.355 L
413.122 427.3342 L
414.8112 430.355 L
416.5921 430.355 L
413.8954 425.6417 L
413.8954 422.7066 L
412.2977 422.7066 L
412.2977 425.6845 l
f
*U
LB
%AI5_EndLayer--
%%PageTrailer
gsave annotatepage grestore showpage
%%Trailer
Adobe_Illustrator_AI5 /terminate get exec
Adobe_ColorImage_AI6 /terminate get exec
Adobe_level2_AI5 /terminate get exec
%%EOF
